  В. М. Бондарев
   
   
   
   
   
   
   
   
   
 Основы программирования.js
 
   
   
   
   
   
   
   
  Учебное пособие
  
  
  
  
  
  
  
  
  2015
Введение 
  Что изучаем
   Цель этого курса, как следует из его названия, изучение основ, а не языка программирования. Изучить основы – значит познакомиться с такими понятиями программирования как команда, переменная, функция, массив, и с их помощью начать писать небольшие программы. Не менее важно  сформировать правильное представление о программировании в целом [1, 2], но это процесс длительный, здесь его можно только начать.  
   Разумеется, цели не достичь без языка программирования, и тут мы должны сделать выбор. Посмотрим на завсегдатаев топа рейтингов популярности. 
   С, С++ – предназначены для написания экономных и высокопроизводительных программ, как правило, системных. Программы на С++ обгоняют программы на других языках, как гоночный автомобиль обгоняет обычные. Но учиться программировать на них, все равно, что учиться азам вождения, сев за руль гоночного автомобиля – дорого и долго.
   Java и C# – два лидера прикладного программирования. Оба представляют крупные конкурирующие платформы, оба развиваются параллельными путями и в своем развитии уже приблизились по сложности к С++. Выбор между ними лучше делать уже получив некоторый опыт, т.к. программирование на Java или C# потребует изучения не только языков, но и обширных библиотек классов, на которые они опираются.
   Python – прекрасный язык для обучения – с низким порогом вхождения, динамической типизацией, двумерным синтаксисом, краткий и выразительный. Основной недостаток – отсутствие понятных начинающим программистам графических библиотек, нам полгода придется писать только консольные программы. 
   PHP – направлен на создание серверной части интернет-приложений и не является языком программирования общего назначения. По одной только этой причине нам не подойдет.
   Pascal – давно вышел из верхней части рейтинга популярности, но имеет огромные заслуги перед образованием. На нем выучилось не одно поколение программистов, но год рождения, 1970-й, наводит на мысль о заслуженном отдыхе. Его реинкарнация – Delphy также пережил свой золотой век и побежден вышеупомянутыми C# и Java.
   Конечно, это не все кандидаты, достойные внимания, но у остальных есть один общий «недостаток» – автор недостаточно знаком с ними, поэтому пора подводить черту.
   Нам кажется, что первый язык программирования должен быть простым в освоении. Он должен быть современным и популярным, чтобы иметь активное сообщество и документацию. Он должен позволять писать привлекательные программы, чтобы учиться было не скучно. Он должен поддерживать разные стили программирования, а не какой-то один. Неплохо также, чтобы он пригодился в будущем, а не пылился на чердаке нашей памяти. Этот перечень требований очень напоминает характеристику языка JavaScript, поэтому мы выбрали его.
   Тем не менее, мы не станем изучать JavaScript (далее JS) досконально. Некоторые его черты обусловлены историческими причинами и не являются значимыми для программирования в целом. Есть и такие, до которых у нас попросту руки не дойдут – курс все таки вводный в программирование. Беды здесь никакой нет, освоив основы, вы сами разберетесь во всех деталях, если под рукой будет хороший учебник [3].
  Структура книги
   Пособие состоит из двадцати небольших разделов. 
   Первые пять посвящены простым типам данных и базовым конструкциям управления – блоку, условной команде, циклу. 
   В следующих трех разделах – знакомство со ссылочными типами данных – объектами и массивами. 
   В девятом разделе – разговор об HTML, достаточный для организации пользовательского интерфейса наших программ.  
   В разделах с 10 по 13 рассматриваются системы счисления и некоторые алгоритмы, включая рекурсивные. Там же на элементарном уровне вводится понятие временной сложности алгоритма и ее оценки.
   Следующие четыре раздела, с 14 по 17, повествуют о графике и анимации, доступных в HTML и JS.
   Наконец, последние три раздела посвящены программированию с объектами и азам проектирования программ.
   На всем протяжении книги текст сопровождается примерами кода и задачами для самостоятельного решения. Предполагается, что читатель сможет воспроизвести примеры на своем компьютере и решить большую часть задач. 
   
  Откуда все пошло
   Первым программистом на нашей планете считается Aда Лавлейс. Она написала ряд программ для несуществующей вычислительной машины, с целью доказать ее полезность. 
   Машину собирался построить английский математик и инженер Чарльз Бэббидж. К тому времени он уже создал несколько механических вычислителей, но все они действовали по встроенной в них программе и не нуждались в услугах программиста.
   Историческая справка
Ча?рльз Бэ?ббидж (1791 - 1871) — английский математик, изобретатель первой вычислительной машины. Иностранный член-корреспондент Императорской академии наук в Санкт-Петербурге. Оставил труды по теории функций, механизации счёта в экономике. Сконструировал и построил (1820-22) машину для построения таблиц математических функций. В 1833 разработал проект универсальной цифровой вычислительной машины – прообраза ЭВМ.

Ада Лавлейс (1815 – 1852), девичья фамилия Байрон (да, да, дочь поэта) – математик. 
Подробно описала вычислительную машину, проект которой был разработан Чарльзом Бэббиджем. Составила первую в мире программу для этой машины. 
      Программа находила числа Бернулли, которые нужны для быстрого  вычисления значений  полиномов. При помощи полиномов составлялись таблицы математических функций, и эту работу предполагалось передать машине.
      Ввела в употребление термины «цикл» и «рабочая ячейка», считается первым программистом в истории. Ее именем назван алгоритмический язык "Ада".

   Создание машины с изменяемой программой вычислений сулило огромные возможности, но не состоялось по причине недостатка финансирования, а главным образом потому, что идеи Бэббиджа опережали существовавшую тогда элементную базу – бронзовые валики и шестерни.
   Поражает то, что аналитическая машина Бэббиджа состояла почти из тех же функциональных блоков, что и ЭВМ, построенные сто двадцать лет спустя (рис.1). 
   
   Рисунок 1 – Функциональный состав машины Бэббиджа и первых ЭВМ
   
   Языки программирования
   Программы Ады Лавлейс внешне напоминали таблицы чисел. Почти так же выглядели и первые программы для электронных вычислительных машин. Началом пути к современному программированию была замена числовых кодов мнемоническими буквосочетаниями. Например, если раньше операция сложения обозначалось числом 01, то теперь – словом "ADD". Дальше – больше и уже в начале 60-х годов прошлого века программы стали писать на Фортране - языке, отдаленно напоминающем английский с большой дозой арифметических выражений. В арифметических выражениях встречались и переменные, но о них чуть позже.
   Компиляторы и интерпретаторы
   Хотя программисты с энтузиазмом придумывали все новые алгоритмические языки, процессор компьютера по-прежнему воспринимал только язык числовых команд. Поэтому с каждого вновь придуманного языка программирования требовался переводчик на язык процессора. К счастью роль переводчика могла выполнять программа, написанная на языке процессора или на ином языке, но впоследствии переведенная на язык процессора.
   Программа-переводчик называется транслятором. Если переводу подвергаются все команды программы, а затем из них составляется (компилируется) программа на языке процессора, переводчик называют компилятором. Если перевод команд программы перемежается их выполнением, переводчик называют интерпретатором.
  JavaScript
   Язык JavaScript появился в 1995 году. Он понадобился для программирования поведения интернет-браузера при показе web-страниц. JS задумывался как очень простой язык, доступный даже не профессиональному программисту.
   Историческая справка
Язык JavaScript создан в компании Netscape. Ведущим разработчиком языка был американский программист Брендан Эйх (или Айк). С самого начала язык был поддержан рядом программистских компаний, в т.ч. и Sun Microsystems, разработчиком Java. Этим объясняется присутствие слова Java в названии языка – для продвижения JavaScript разработчики хотели воспользоваться рекламной компанией быстро набирающего силу Java.
По инициативе компании Netscape язык был стандартизован. Стандартизированная версия имеет название ECMAScript, описывается стандартом ECMA-262.
   
   Сейчас, в силу разных обстоятельств, значение JavaScript неизмеримо возросло. Главное обстоятельство то, что неизмеримо возросло значение браузеров, а JS – единственный язык, который понимают все браузеры. Слово  «понимают» означает, что интерпретаторы JS встроены во все браузеры. 
   Позднее JS стали применять и за пределами браузеров, и он получил статус универсального языка программирования, такого же, как Java, C#, Фортран, Лисп или Питон.  Приобретенная важность не лишила JS простоты, к тому же интерпретатор JS у нас всегда под рукой – в любом браузере. 
   Возьмите Блокнот (т.е. текстовый редактор Notepad) и наберите в нем такой текст:
   
<script>
   alert(2 + 3);
</script>
   Этот текст является очень короткой, из одной команды, программой на JS. Команда alert выводит в особое окно результат арифметического выражения в скобках. Тэги <script> и </script> отмечают для браузера начало и конец программы и к самой программе не относятся.
   Сохраните набранный текст в файле с расширением html, скажем, «first.html» и откройте в любом браузере. В небольшом окошке вы увидите скромный результат своих усилий.
   Когда браузер отрывает файл, в котором находится пара тэгов <script>…</script>, он выполняет заключенный в них программный код при помощи встроенного интерпретатора JS. Результат этого процесса мы видим на экране компьютера.
1. Числа и выражения. Присвоение имен
   Первые компьютеры строились для вычислений – нужно было расшифровывать вражеские донесения и рассчитывать траектории снарядов, ведь шла война. С другой стороны, все в этом мире можно обозначить числами – буквы, иероглифы, ноты, цвета, положение звезд на небе, перепады настроения, в общем, все. Поэтому нет ничего удивительного в том, что мы начнем знакомство с программированием именно с чисел.
  Запись чисел в JS
   Числа в JS записываются так же, как в обычной жизни: 245, -8, 3.14, только вместо десятичной запятой по английской традиции ставится точка.
   Очень большие и очень маленькие, близкие к нулю, числа записываются в научной нотации: 1.98892E30 (1.98892*1030 – масса Солнца в килограммах),   6.67385E-11 (6.67385*10-11 – гравитационная постоянная в системе СИ).  В научной записи буква E (от слова exponent) разделяет два десятичных числа – мантиссу и показатель степени.
  Числовые выражения
   Из чисел при помощи знаков операций и круглых скобок можно составлять выражения: 2 * 2, (3.5 + 4.5) / 2,  1 + 2 + 3.  
   Правила составления выражений те же, что в школьной арифметике, только умножение обозначается звездочкой, и есть еще одна операция – взятие остатка от деления. Эта операция обозначается знаком процента.
   8 % 3 = 2
   10 % 2 = 0
   1 % 10 = 1
   При помощи операции % можно делать всякие полезные вещи, например, найти младший разряд числа.
   
<script>
   alert(375 % 10);
</script>
   Когда интерпретатор встречает в программе  числовое выражение, он его вычисляет и поступает с полученным значением так, как того требует программа, в  нашем примере это был вывод в окно командой alert. 
  Имена
   В языках программирования можно не только вычислять выражения, но и давать выражениям имена. Перепишем нашу первую программу таким образом. 
   
<script>
   var sum = 2 + 3;
   alert(sum);
</script>
   В первой строке программы мы даем арифметическому выражению «2+3» имя sum. 
   
var sum = 2 + 3;
   Во второй строке показываем значение выражения в окне, сославшись на выражение по имени.
   
alert(sum);
   В качестве имен можно использовать любые последовательности букв и цифр, но начинаться они должны только с буквы. Например, «script», «An24», «first» – это имена, а «1С», «ping-pong», «King Kong» – нет, ибо дефис и пробел буквами не являются. Впрочем, символ подчеркивания и символ доллара JS причисляет к буквам, поэтому «ping_pong» и «$100» – это имена.
  Команда присваивания
   Команда, которая присваивает имена выражениям, так и называется – присваивание. Общий вид или схема этой команды такова:
   
var имя = выражение;
   Слово  var относится к ключевым или зарезервированным словам языка JS. Ключевые слова нельзя использовать в качестве имен, они нужны интерпретатору, чтобы распознавать команды.
   Русским словами в схеме обозначены те элементы команды, которые в конкретной программе будут заменены конкретными именами и выражениями.
   Одно число или одно имя тоже считаются выражениями, поэтому присваивания:
   
var first = 1;
var second = first;
вполне правомерны.
   Когда какое-то имя впервые присваивается выражению, перед ним пишут слово “var” (от слова variable – переменная). При повторных присваиваниях слово var можно не писать.
   Хотя правила записи присваивания просты, их нужно строго соблюдать. Например, нельзя поменять местами имя и выражение, вот так, 
   1 = first;
интерпретатор вас не поймет.
   Впрочем, вы можете опустить ключевое слово var даже в первом присваивании или не поставить точку с запятой в конце команды – работа наших примеров не изменится. Но в более сложных программах эти вольности чреваты ошибками, поэтому будем избегать их и делать все по правилам.
   
   Давать имена выражениям бывает очень полезно, например,  нам нужно вычислить  длинное выражение:
   	(1 + 6 / 3) * (1 + 6 / 3) + 3 / (1 + 6 / 3)
   Вместо одной команды
   
alert ((1 + 6 / 3) * (1 + 6 / 3) + 3 / (1 + 6 / 3));
   лучше написать программу из двух команд.
   
var x = 1 + 6 / 3;
alert(x * x + 3 / x);
   Или даже из трех для большей ясности:
   
var x = 1 + 6 / 3;
var y = x * x + 3 / x;
alert(y);
  Игра воображения
   Вообразим себе память компьютера как множество ячеек камеры хранения. Ячейки пронумерованы, но их номера программисту не важны и не известны. 
   Что происходит при выполнении (т.е. при интерпретации) следующей команды?
   var x = 2 + 3;
   Дадим волю нашему воображению.
   Может быть, выражение вычисляется, его результат, помещается в свободную ячейку и ей присваивается имя «x»?
   А может быть, в свободную ячейку помещается само выражение «2 + 3», ей дается имя «x» а вычисление происходит, когда результат нужно показать?
   По первому сценарию вычисление произойдет в первой команде программы
   
   var sum = 2 + 3;
   alert(sum);
   По второму сценарию вычисление будет отложено и произойдет только во второй команде.  В любом случае результат будет одинаковым – в окне появится число 5. 
   Рассмотрим еще один пример.
   
var x = 1 + 6 / 3;
var y = x * x + 3 / x;
alert(y);
   По первому сценарию сначала вычисляется выражение «1 + 6 / 3», и его результат, число 3, сохраняется в ячейке с именем x. 
   Затем вычисляется второе выражение. Чтобы вычисление выражения стало возможным, все имена, входящие в выражение, должны быть замещены их значениями, т.е. все вхождения имени «x» в выражение «x * x + 3 / x» заменятся числом 3. Результат вычисления, число 10, сохранится в ячейке с именем y. В целом придется выполнить пять арифметических операций, две в первой команде и три во второй.
   По второму сценарию в ячейке x сохранится выражение «1 + 6 / 3», а в ячейке y – результат подстановки, т.е. выражение «(1 + 6 / 3) * (1 + 6 / 3) + 3 / (1 + 6 / 3)». Вычисления произойдут, когда понадобится вывести результат, и потребуют девяти арифметических действий.
   Как видим, первая модель вычислений более быстрая, но и у второй модели есть свои достоинства. Представьте, например, что имя «x» в ходе дальнейших вычислений не понадобилось, тогда не будут выполнены и ненужные арифметические операции, а в первой модели их не избежать.
   Заметим, что может быть и третья модель – выражение вычисляется, кладется в безымянную ячейку, а номер безымянной ячейки сохраняется в ячейке с именем «x». А может быть и четвертая, и пятая…
   Не буду вас томить, интерпретатор JS использует первую и третью модели вычислений, но по отношению к числам – только первую. 
   
   Замечание. Вторая модель также применяется в программировании ( но не в JS) и называется отложенными или «ленивыми» вычислениями.
   
   Таким образом, можно считать, что имя дается не числовому выражению, а его значению. Остается ответить на несколько вопросов.
   Что произойдет, если во втором примере мы забудем присвоить имя х  некоторому значению?  
   – Интерпретатор не сумеет вычислить выражение, в которое входит x, и результата мы не увидим.
   Что будет, если сначала дать имя x одному значению
   	var x = 1 + 6 / 3; 
а позже дать то же самое имя другому значению?
   	var x = 3 + 2;
   – В ячейке с именем x число 3 сменится числом 5. Куда подевалось 3? Просто исчезло, как исчезает старое изображение на экране дисплея при появлении нового.
   Программисты называют именованные ячейки памяти переменными (ключевое слово var – от variable), поскольку их содержимое может меняться в процессе выполнения программы. 
   
   Замечание. Поясняя смысл команды присваивания x = 3 + 2, часто говорят, что переменной х присвоено значение 5. Так что же на самом деле, имя х присвоено значению выражения, или значение выражения присвоено переменной с именем x? И то, и другое правильно. В результате присваивания имя x ассоциируется со значением 5, а каким образом сообщить об этом – не существенно.
   
   Вот задача, о которую обломало зубы не одно поколение начинающих программистов. Есть две переменные, скажем a и b. Необходимо обменять их значения, т.е. если изначально было a = 4, b = 5, после обмена должно стать  a = 5, b = 4. Программа не должна зависеть от конкретных значений переменных a и b, она должна обменивать любые значения.
   Распространенной ошибкой является такая версия программы:

a = b;
b = a;
   В самом деле, первое присваивание приведет к тому, что содержимое ячейки b будет скопировано в ячейку a. Второе присваивание поместит в ячейку b то же самое число, что уже там находится. В итоге в обеих ячейках окажется первоначальное содержимое ячейки b, число же, бывшее в ячейке a, исчезнет бесследно. 
   Выход в использовании третьей ячейки, например, с именем t (от слова temporary – временный), Ада Лавлейс назвала бы ее рабочей ячейкой. 
   
var t = a; // в t идет копия числа из a
a = b;     // в a идет копия числа из b
b = t;     // в b идет копия числа из t (числа из а)
   Мы овладели уже двумя командами JS: присваиванием и alert, и пора начинать программировать. Вот первая порция задач для самостоятельного решения. 
   
1.1. Напишите программу, которая подсчитает, сколько секунд в 2016 году.
1.2. Определите, сколько минут понадобится свету, чтобы долететь от Солнца до Земли (расстояние – 150 млн.км, скорость – 300000 км/сек).
1.3. Подсчитайте, сколько пикселей помещается на экране вашего монитора при текущем разрешении?
1.4. Напишите программу, которая покажет в окне два последних (младших) разряда произвольного целого числа.
1.5. Напишите программу, которая покажет в окне предпоследний разряд целого числа. Если, например, число 4567, программа должна показать 6.
1.6. Дано трехзначное целое число. Выведите на экран сумму его цифр.
   
   Решать задачи можно так, как мы проверяли примеры кода – в Блокноте изготовьте текстовый файл с тэгами <script> и </script> и кодом решения между ними, после чего откройте файл в web-браузере. 
   Web-браузер открывает файл, если набрать в адресной строке браузера «file:///путь_к_файлу». Например, вы создали файл first.txt в папке MyJS на диске D:. В адресной строке наберите: «file:///D:/MyJS/first.txt». 
   Если же вы дадите файлу расширение html, то наверняка сможете отрыть его браузере двойным щелчком мыши.
   
  Значение undefined
   Зададимся вопросом, что покажет в окне следующая программа?
   
<script>
   var z;
   alert(z);
</script>
   Загрузив программу в браузер, увидим, что в окне появится слово undefined. В JS всем переменным, которым еще ничего не присвоено, изначально присвоено особое значение undefined.
   
	Замечание. Не стоит выполнять никакие арифметические действия со значением undefined, ибо результатом будет другое особое значение, NaN, которое означает Not a Number, не число.
  Заключение
1. Чтобы писать и выполнять программы на JS, нужны только текстовый редактор и интерпретатор JS.  Последний входит в состав любого современного веб-браузера, и мы будем использовать браузер, как среду выполнения наших программ.
2. Программа на JS состоит из команд, которые выполняются последовательно в том порядке, в каком написаны.
3. Из команд нам пока известны две: присваивание и вывод в окно (alert). Вторая команда – не совсем команда, а функция, но пока понятие функции нам не знакомо, будем временно называть alert командой.
4. Чтобы предсказать поведение программы, программист должен иметь представление о модель вычислений. Мы рассмотрели одну из двух моделей вычислений, принятых в JS, а именно, ту, что применяется  для чисел и других простых значений. Будем называть ее простой моделью. 
2. Условные команды
  Односторонняя условная команда
   До сих пор все команды в наших программах выполнялись интерпретатором безусловно – есть команда, он ее выполнит, нет команды … сами понимаете.
   Сейчас мы познакомимся с условной командой, которая сделает наши программы намного интереснее. Схема условной команды такова.
   
if (условие) 
   команда;
   Здесь if – ключевое слово, в круглых скобках записано условие, а слово «команда» означает любую команду языка JS. На схеме русские слова помечают те места, которые должны занять конкретное условие и конкретная команда. 
   Условие – это выражение, которое интерпретатор сможет трактовать как истинное или ложное. В частности, любое числовое выражение, со значением отличным от нуля, трактуется в JS как истина, число нуль интерпретатор считает ложью. Значение undefined тоже воспринимается интерпретатором как ложное.
   Выполнение условной команды интерпретатор начинает с вычисления условия. Если интерпретатор сочтет условие истинным, он выполнит вложенную команду. Если интерпретатор посчитает результат ложным, вложенная команда выполнена не будет.
   Пример 1.  Пусть x – некоторое число. Показать его в окне, если оно отлично от нуля. 
   С этой задачей справится следующая программа. 
   
<script>
   if (x)
      alert(x);
</script>
   Чтобы убедиться в работоспособности программы, нужно присвоить переменной x некоторое значение, для этого добавим в программу проверочное присваивание.
   
<script>
   var x = 5;
   if (x)
      alert(x);
</script>
   Пример 2. Найти решение уравнения ax + b = 0. Если решения нет, переменная x должна остаться неопределенной (undefined).
   
<script>
   var a = 10, b = 3; 
   if (a) 
      var x = -b / a;
   alert(x);
</script>
   Вы понимаете, что первая и последняя строки нужны для проверки решения. Чтобы проверка была полнее, выполним программу повторно, заменив первую строку.
   
   var a = 0, b = 3; 
   Как видно из примера 2, в одной строке можно разместить несколько присваиваний. Это делать совсем не обязательно, но мы иногда будем так поступать для экономии места на странице. По этой же причине не станем воспроизводить в примерах окружающие код тэги <script>…</script>.
  Логические выражения
   Итак, условие – это выражение. Но мы не можем назвать его арифметическим, ведь конечным результатом его вычисления является не число, а логическое значение, «истина» или «ложь». 
   Кроме того, и это важно, в условиях могут присутствовать сравнения. В языке JS их шесть:
   ==,  !=, >, <, >=, <=.
   Вот типичные примеры условий.
   
if (x > 0) …
if (a == b) …
if (a != b + 1) …
    Проверка на равенство обозначается сдвоенным знаком «равно», чтобы отличить ее от присваивания. Неравенство обозначается «!=», т.к. перечеркнутого знака равенства на клавиатуре нет. Несмотря на двухбуквенность, сравнение для интерпретатора это один знак (программисты говорят – одна лексема), и вставлять пробел так «= =», или так «! =», или так «< =» нельзя. 
Позднее мы еще вернемся к логическим значениям, а пока решим пример. 

Пример 3. В переменных a и b какие-то числа. Показать в окне большее из них.

   var a = 5, b = 8;

   if (a > b)
      alert(a);
   if (a <= b)
      alert(b);
   Первая строка программы не входит в решение, она нужна лишь для его проверки. Чтобы сделать проверку более полной, программу нужно выполнить несколько раз, меняя в ней первую строку, например, так:

   var a = 8, b = 5;
   var a = 5, b = 5;
   var a = -5, b = -8;
   В примере 3 нам пришлось дважды вычислять условия, вначале условие «a > b», а затем противоположное ему условие «a <= b». 
   
   Замечание. Условием, противоположным условию А, называется такое условие В, которое истинно всегда, когда В ложно, и напротив, ложно всегда, когда B истинно.
   
   Необходимость вычислять два противоположных условия возникает так часто, что в алгоритмических языках, наряду с односторонней условной командой, существует двусторонняя. 
  Двусторонняя условная команда
   Вернемся к примеру 3 с выводом в окно большего из двух чисел.
   
   if (a > b)
      alert(a);
   if (a <= b)
      alert(b);
   Если применить двустороннюю условную команду, интерпретатору не придется вычислять второе условие.
   
   if (a > b)
      alert(a);
   else
      alert(b);
   Общая схема двусторонней условной команды такова.
   
if (условие) 
   команда1;
else 
   команда2;
   Здесь else – зарезервированное слово языка, команда1 и команда2 – произвольные команды JS. Если условие истинно, интерпретатор выполнит только команду1, если условие ложно, только команду2. 
   
2.1. Даны три числа, a, b и с. Вывести на экран наибольшее из них. 
Совет. Задачу лучше решать в два этапа: во-первых, найти большее из двух чисел a и b и присвоить его переменной t, во-вторых, вывести на экран большее из чисел, c и t.
2.2. Вывести на экран большее из четырех чисел: a, b, c и d. 
2.3. Написать программу, которая показывает число в окне, только если оно больше 10, но меньше 100. Совет: вложите условную команду в условную команду.
   
   Пример 4.  Напишем программу решения квадратного уравнения 
   ax2 + bx + c = 0. Искать будем только вещественные корни.
   
   Чтобы задать любое квадратное уравнение, достаточно иметь в программе три переменные: a, b и c. Например, если нужно решать уравнение 2x2 + 3x - 5 = 0, то присвоим
   var a = 2, b = 3, c = -5;
   Для корней уравнения отведем переменные x1 и x2. Наша задача в том, чтобы написать программу, которая из значений переменных a, b и c выработает значения переменных x1 и x2, если это возможно. 
   Работа предстоит не маленькая, поэтому составим план. 
1. Вначале найдем дискриминант d = b2 – 4ac.
2. После этого вычислим корни. 
   Теория гласит, что если d < 0, вещественных корней нет. В этом случае оставим x1 и x2 неопределенными. Если же d >= 0, корни есть и вычисляются по формулам: 
   x1 = (-b + ?d) / 2a, 
   x2 = (-b - ?d) / 2a.
Пока формулы написаны не совсем на JS, но мы это исправим. Заметим, мы не рассматриваем отдельно возможность, когда d == 0, в этом случае наши два корня просто будут одинаковыми.
   Вот возможное решение с комментариями. Тэги <script> опущены.
   
// Задаем конкретное уравнение
var a = 2, b = 3, c = -4; 

// Вычисляем дискриминант
var d = b * b - 4 * a * c;

// Находим первый корень 
if (d >= 0) 
   var x1 = (-b + Math.sqrt(d)) / (2 * a);

// Находим второй корень 
if (d >= 0) 
   var x2 = (-b - Math.sqrt(d)) / (2 * a);
 
alert(x1);
alert(x2);
   Комментарий – это любой текст, который начинается двумя слешами и продолжается до конца строки. 
   Интерпретатор комментарии попросту игнорирует, а человеку они могут помочь разобраться в программе (но могут и помешать, если плохо написаны).
   При вычислении дискриминанта мы заменили b2 операцией умножения b*b.
   Извлечение квадратного корня из произвольного числового выражения в JS делается при помощи математической функции Math.sqrt.
   
Math.sqrt(выражение)
   Когда интерпретатор встречает такое выражение, он вычисляет выражение в скобках, извлекает из него квадратный корень и подставляет его вместо всей конструкции.
   Кроме sqrt, в JS имеются и другие математические функции, например:
   Math.abs(x) – абсолютная величина числа x,
   Math.sin(x) – синус числа x,
   Math.pow(x, y) – возведение числа x в степень y,
   и другие. 
   Мы будем использовать их по мере надобности, но не станем злоупотреблять, т.е. когда понадобится возвести x в квадрат, будем писать x * x, а не Math.pow(x, 2). 
   Причина в том, что вычисление значения функции традиционно считается более длительной операцией, чем арифметическое действие. К тому же функции, решающие общие задачи, например, возведение произвольного числа в произвольную степень, производят большой объем вычислений, и в данном случае произойдет «стрельба из пушки по воробьям».
  Составная команда
   В нашем решении квадратного уравнения есть одна особенность, и не скажу, что приятная. Поскольку в условную команду может быть вложена лишь одна команда, нам пришлось дважды написать if и дважды проверить одно и то же условие.
   
// Находим первый корень 
if (d >= 0) 
   var x1 = (-b + Math.sqrt(d)) / (2 * a);

// Находим второй корень 
if (d >= 0) 
   var x2 = (-b - Math.sqrt(d)) / (2 * a);
   Составная команда (ее также называют блок) позволяет упаковать несколько команд в одну и тем самым обойти ограничение условной команды: «лишь одна команда внутри». 
   Схема составной команды такова.
   
{ 
   команда1;
   команда2;
   … 
}
   Перепишем, используя блок, огорчивший нас фрагмент программы.
   
// Находим корни 
if (d >= 0) 
{
   var x1 = (-b + Math.sqrt(d)) / (2 * a);
   var x2 = (-b - Math.sqrt(d)) / (2 * a);
}
  О форматировании кода
   Мы привыкли к тому, что всякий документ должен быть аккуратно отформатирован. Небрежность в этом отношении мешает читателю воспринимать смысл написанного и настраивает его против автора.
   Совершенно по тем же причинам следует форматировать код программы. Пока достаточно соблюдать несколько простых правил.
   Правило первое. Вложенность команд показывают отступами. Отступы делают при помощи трех пробелов. 
   Правило второе. При написании блока закрывающая фигурная скобка должна располагаться точно под открывающей.
   Правило третье. Если в программе есть несколько смысловых частей, их отделяют друг от друга пустыми строками.

Замечание. Среди программистов бытует мнение, что даже одну вложенную команду следует окружать фигурными скобками, т.е. вместо

if (a > b)
   alert(a);
else
   alert(b);
писать

if (a > b)
{
   alert(a);
}
else
{
   alert(b);
}
Считается, что такой код менее подвержен случайным ошибкам и лучше читается. Не оспаривая это утверждение, в книге мы будем избегать лишних скобок, чтобы примеры занимали меньше места.
  Ветвления в программе
   В JS есть односторонняя и двусторонняя условные команды. А есть ли трехсторонняя или четырехсторонняя?  Ведь иногда приходится делать выбор из нескольких альтернатив.
   Таких команд в языке нет, но их можно соорудить самому из тех, что есть. 
   Пример 5. Пусть переменная t (от слова time) содержит время дня. 
Если t < 12, вывести в окно слово «утро», 
иначе если t < 18, вывести в окно слово «день», 
иначе вывести в окно слово «вечер».
   
Показать в окне строку символов так же просто, как показать число:

alert("утро");   
alert("день");   
alert("вечер");    
Нужно только заключить строку в кавычки, в двойные или в одинарные, это все равно. Запрещены лишь гибриды – слева одинарная, справа двойная и наоборот.
   Чтобы решить поставленную задачу, нужно лишь перевести ее условие с русского языка на JS.
   
   // это для проверки. Вместо ??? напишите число
   var t = ???;  

   if (t < 11) 
      alert("утро");   
   else if (t < 18) 
      alert("день");   
   else
      alert("вечер");  
   В решении умышленно не задана переменная t, ведь для проверки решения программу нужно выполнить с разными ее значениями.
   В коде также умышленно нарушено правило отступов. Если его придерживаться, код станет таким.

   if (t < 11) 
      alert("утро");   
   else 
      if (t < 18) 
          alert("день");   
      else
          alert("вечер");  
Но мы хотели имитировать многостороннюю условную команду, поэтому нарушение оправдано. 

   Замечание. В тех языках, где такая команда есть (Бэйсик, Питон), она отличается от нашей конструкции в основном тем, что слова else if пишутся слитно. В тех языках, где такой команды нет (C++, Java, C#),  поступают так, как сделали мы – сознательно нарушают правило отступов.
2.4. Охарактеризовать заданное число x как отрицательное, ноль или положительное, т.е. в зависимости от величины x вывести в окно одно из трех слов: «отрицательное», «ноль», «положительное».
2.5. Дано целое число. Охарактеризовать его как "круглое", "полукруглое" или "некруглое". Круглым числом считается то, которое оканчивается нулем, полукруглым – то, что оканчивается на 5, некруглыми – все остальные.
2.6. Оценки студентам ставят в двух разных шкалах – пятибалльной, чтобы было понятно родителям, и стобалльной, для подсчета рейтинга. Соотношение между шкалами задает следующая таблица.
    
100 балльная шкала
5 балльная шкала
90 – 100
   5
75 – 89
   4
60-74
   3
0-59
   2
   
Напишите программу, которая переведет оценку, поставленную по стобалльной шкале, в оценку по пятибалльной шкале.
  Заключение
1. Условные команды фактически являются контейнерами, в которые вкладывают одну (для односторонней) или две (для двусторонней) любые команды языка. Если вместо одной команды нужно вложить несколько, их объединяют в блок.
2. Многократным вложением одной условной команды в другую можно разделить вычисление на любое количество равноправных альтернатив.
3. Чтобы сделать структуру программы очевидной, ее нужно правильно форматировать. Форматирование, главным образом, заключается в отступах, число которых равно глубине вложенности команд.
3. Команды повторения
   Большинство алгоритмов включают в себя повторение одних и тех же команд. Если бы не было повторений, никакая армия программистов не обеспечила бы современные компьютеры нужным количеством программ, ведь скорость исполнения программ порядка миллиарда команд в секунду, а средняя скорость написания программ порядка нескольких команд в день, а с учетом выходных и праздников еще меньше.
  Команда while
   Команда повторения while выглядит почти как условная команда, только место ключевого слова if занимает ключевое слово while.
   
while (условие) 
   команда;
   Выполнение команды while начинается с проверки условия. Если условие истинно, выполняется вложенная команда и все повторяется: проверка условия – выполнение команды, проверка условия – выполнение команды и т.д., пока очередная проверка не покажет, что условие ложно. Тогда команда while завершится, и интерпретатор двинется дальше.
   Попробуем выполнить следующую программу.
   
while(1)
   alert ("Еще раз привет.");
   Команда alert повторяется бесконечно – ничего удивительного, ведь проверяемое условие всегда истинно. 
   Слегка изменим программу и снова выполним.
   
while(0)
   alert ("Еще раз привет.");
   Мы вообще ничего не увидим, т.к. проверяемое условие ложно и вложенная команда  не выполнится ни разу. Напрашивается вывод: чтобы команда повторения имела смысл, вложенная команда должна как-то влиять на проверяемое условие.
   Например, так.
   
var i = 0;

while(i < 5)
{
   alert ("Еще раз привет.");
   i = i + 1;
}
   Здесь роль вложенной команды выполняет составная команда, вторая строка которой увеличивает на 1 значение переменной i. Поэтому условие i < 5 рано или поздно станет ложным, и повторения прекратятся.
   Как вы полагаете, сколько раз появится окно со словами "Еще раз привет." ? Если затрудняетесь ответить, просто выполните программу.
   
   Пример 1. Вывести в окно поочередно числа 0, 1, 2, 3, 4.
   
var i = 0;
while(i < 5)
{
   alert (i);
   i = i + 1;
}
   Можно организовать обратный отсчет, как при запуске ракеты в космос.
   
var i = 5;
while(i > 0)
{
   alert (i);
   i = i - 1;
}
alert ("Пуск!");
   Пример 2. Просуммировать целые числа от 1 до миллиона.
    
var sum = 0;
var i = 1;
while(i <= 1000000)
{
   sum = sum + i;
   i = i + 1;
}
alert (sum);
   Для накопления суммы мы отвели специальную переменную, sum. Исходное значение этой переменной – нуль, так как складывать что-то с undefined невозможно. Далее по уже знакомой схеме последовательно получаем все слагаемые в переменной i – в каждом повторении одно слагаемое. 
   Согласно простой модели вычислений присваивание 
       i = i + 1;  
означает, что число из ячейки i складывается с 1 и результат возвращается в ту же ячейку. Аналогично работает и присваивание 
       sum = sum + i; 
поэтому после окончания всех повторений в переменной sum окажется требуемая сумма.
  Комбинированные присваивания
   Команда 
       sum = sum + i;
заставляет интерпретатор дважды обращаться к переменной sum: первый раз, чтобы извлечь из нее число, второй раз, чтобы положить обратно сумму. Ввиду того, что присваивания 
   
переменная = переменная + выражение;
встречаются в программах весьма часто, в JS есть команда комбинированного присваивания
   
переменная += выражение;
результат которой такой же, как в предыдущем случае. Отличие в том, что комбинированное присваивание интерпретируется более экономным образом, т.к. выполняя его, интерпретатор будет искать ячейку sum не два, а только один раз и потому затратит меньше времени.
   Кроме присваивания +=, в JS есть комбинации присваивания со всеми арифметическими и логическими операциями: -=, *=, /=, %=, … (о логических операциях будет сказано позднее).
  Параметры программы
   Решим пример 2 в более общей форме: "Найти сумму целых чисел от m до n включительно".

var m = ???, n = ???;

var sum = 0;
var i = m;
while(i <= n)
{
   sum += i;
   i += 1;
}
alert (sum);
   Общая форма лучше частной – код тот же, а сфера  его применения неизмеримо шире. Обобщение достигается за счет параметров – переменных, содержащих начальные условия задачи. Роль параметров в нашем примере играют переменные m и n. Условимся не придавать им конкретных значений, но перед выполнением программы, знаки вопроса следует заменить числами.
   
3.1. Сложить числа 1 + 1/2 + …+ 1/n . Переменную n считать параметром программы.
3.2. Подсчитать сумму n первых нечетных чисел, 1 + 3 + 5 +…+ 2n-1.
 
   Пример 3. Подсчитать сумму ряда: x – x3/3! + x5/5! – x7/7! +… 
   
   Науке известно, что синус  угла в x радиан можно вычислить, сложив члены этого знакопеременного ряда. Для точного значения синуса количество слагаемых должно быть бесконечно, но на практике достаточно и пяти, и чем меньше угол, тем с меньшим количеством слагаемых  достигается заданная точность.
   
	Замечание. Запись k! (k факториал) означает произведение чисел: 1 * 2 * … * k.

   В данной задаче два параметра: x – угол в радианах и n – количество слагаемых. От второго параметра зависит точность вычислений.
   Наиболее очевидное решение – действовать по той же схеме, что и раньше.
   
var x = ???, n = ???;

var sin = 0, i = 1;
while (i < n) 
{
   // вычислить очередное слагаемое
   var s = …
   // добавить его к сумме
   sin += s; 
}
alert(sin)
   Проблема в том, что вычисление очередного слагаемого не простое дело и само требует повторений, хотя бы для того, чтобы найти факториал. 
   Вместо этого попробуем выразить очередное слагаемое через предыдущее. 
   s1 = x;
   s2 = s1 * -x2/(2*3);
   s3 = s2 * -x2/(4*5);
   …
   si+1 = si * (-x2)/(2i(2i + 1));
   
   Наблюдения показывают, что 1-е слагаемое равно x, а (i + 1)-е слагаемое отличается от i-го сомножителем 
   p = -x2/(2i (2i – 1)).

var x = ???, n = ???;

var sin = 0, i = 1;
var s = x;     // это первое слагаемое
while (i < n) 
{
   sin += s; 
   // вычислить очередное слагаемое
   s *= -x * x / (2 * i * (2 * i + 1));
   i += 1;
}
alert(sin);
Для проверки выберем угол в 30 градусов, все знают, что его синус равен 0.5.
Там же, где находятся математические функции, есть и весьма точное значение числа пи: Math.PI.

var x = Math.PI/6, n = 10;
3.3. Задано n. Сложить квадраты: 12 + 32 + 52 + …+ (2n – 1)2.
3.4. Вычислить n!
3.5. Найти сумму факториалов от 0! до n!.
3.6. Просуммировать степени двойки с 0-й по n-ю: 20 + 21 + 22 +…+ 2n. 
  Поиск НОД. Алгоритм Евклида
   Задача поиска наибольшего общего делителя двух чисел дает хороший пример применения команды повторения. 
   Наибольшим общим делителем двух чисел интересовались еще в Древней Греции, правда, в применении не столько к числам, сколько к отрезкам. Для отрезков задача звучала так. 
   Даны два отрезка с длинами a и b. Найти длину наибольшего отрезка, который целое число раз укладывается в оба данных отрезка. 
   Алгоритм решения был описан Евклидом и поэтому носит его имя.
   Историческая справка
   Евклид – древнегреческий математик (3 век до н.э.), автор первого из дошедших до нас математических трактатов. По его книгам студенты изучали геометрию в течение двух тысяч лет, а обсуждаемый здесь алгоритм считается одним их первых вычислительных алгоритмов в истории. 
   
   Алгоритм состоял в том, чтобы вычитать меньший отрезок из большего, пока это возможно. Если остаток от вычитаний равен нулю (меньший отрезок уложился в большем целое число раз), то меньший отрезок и есть решение задачи. Если остаток больше нуля, то следует назначить остаток меньшим отрезком, бывший меньший отрезок назначить большим и снова применить к ним изложенный алгоритм. 
   Оказалось, что процесс заканчивается не всегда. Казалось бы, рано или поздно найдется пусть крошечный отрезочек, который можно уложить и в первый, и во второй отрезок. Но нет, существуют отрезки, для которых процесс вычитаний будет длиться бесконечно. Это шокирующее обстоятельство привело к открытию иррациональных чисел.
   Возвращаясь к числам, можно заявить, что для целых чисел алгоритм Евклида всегда завершается, т.к. все они без остатка делятся на 1, и хотя бы такой общий делитель будет найден всегда.  
   Переведем алгоритм Эвклида на  JS.
   
// Даны два числа, a и b (a > b)
var a = ???, b = ???;
// Повторяем, пока меньшее из чисел не равно нулю 
while (b > 0) {
    // Вместо многократных вычитаний сразу находим остаток
    var r = a % b;
    // Назначаем меньшее число большим
    a = b;
    // Назначаем остаток меньшим числом
    b = r;
}
// Когда b == 0, число а – НОД
alert(a);
  Команда for
   Очень часто, если не всегда, в наших примерах присутствовала переменная, которая «управляла» процессом повторений. Вспомним пример 1, в нем повторениями управляла переменная i.
   
var i = 0;
while(i < 5)
{
   alert ("Еще раз привет!");
   i = i + 1;
}
   Чтобы сделать управление повторениями наглядным, во многих языках программирования, в том числе и в JS,  существует еще одна команда повторения – for.
Перепишем код примера 1, используя вместо команды while команду for.
   
for (var i = 0; i < 5; i += 1)
   alert ("Еще раз привет!");
   Общая схемы команды for такова.
   
for (стартовая_команда; условие; изменение_условия) 
   команда
   Порядок действий интерпретатора при  исполнении команды for следующий:
1) выполняется стартовая команда (в примере это var i = 0);
2) проверяется условие (в примере это i < 5);
3) выполняется вложенная команда;
4) происходит изменение условия (в примере это i += 1).
Если в пункте 2) выясняется, что условие ложно, пункты 3) и 4) пропускаются, команда for завершается и выполнение программы идет дальше.
   Заметим, что стартовая команда и изменение условия могут состоять из нескольких выражений, разделенных запятыми. Вот как можно применить цикл for для ранее решенной задачи вычисления синуса.
   
var x = Math.PI/6, n = 10;

for (var sin = 0, i = 1, s = x; i < n; i += 1) 
{
   sin += s; 
   s *= -x * x / (2 * i * (2 * i + 1));
}
alert(sin);
   Не станем утверждать, что такое решение лучше прежнего, это просто демонстрация. 
   
3.7. Напечатать натуральные числа в порядке убывания, начиная с N и заканчивая 1.
3.8. Напечатать все правильные дроби между 0 и 1, в числителе и знаменателе которых только одноразрядные числа: 1/2, 1/3, 1/4, … 2/3, 2/4, …8/9.

   Пример 2. Показать члены ряда Фибоначчи: 1, 1, 2, 3, 5, 8, 13, … величина которых не превышает 100.
   Историческая справка
    Фибоначчи (Леонардо Пизанский) купец и математик, жил в XIII в. в Пизе. Ездил в арабские страны, учился математике по сочинениям Аль-Хорезми и других мусульманских математиков. Написал «Книгу Абака» – учебник, просуществовавший в неизменном виде 600 лет. Первый крупный математик Европы. Активный участник олимпиад по математике, на которых решил и придумал много задач, в том числе следующую задачу о кроликах.
   В загородку поместили двух новорожденных кроликов. Кролики готовы к размножению через месяц, и каждый месяц рождают еще пару кроликов. Сколько кроликов будут сидеть в загородке через n месяцев?
   
   Именно в решении задачи о кроликах впервые возник числовой ряд, который назвали именем  Фибоначчи.
   Первые два члена этого ряда равны единице.
         f1 = f2 = 1;
   Каждый последующий член ряда равен сумме двух предыдущих
         fk = fk-1 + fk-2.
   
   Решение примера 2 может быть таким.
   
var n = 100;
for (var f1 = 1, f2 = 1; f1 <= n; f1 = f2, f2 = f3) {
    alert(f1);
    var f3 = f1 + f2;
}
   Как видите, при помощи только трех переменных, f1, f2, f3, мы смогли напечатать произвольное количество членов ряда. Для этого мы просто "двигали" эти переменные вдоль ряда.
   
3.9. Решите задачу о кроликах.
  Заключение
1. Для повторения команд JS предлагает два способа: команда while и команда for. Обе команды содержат в себе вложенную команду, которая и повторяется. Если нужно повторять не одну, а несколько команд, вкладывают блок.
2. Какой из способов повторения применять, дело вкуса программиста, но больше любят команду for. Впрочем, когда нет четко выраженной управляющей переменной, хороша команда while.
3. Комбинированные присваивания интерпретируются более эффективно, да и выглядят короче. Впервые они появились в языке Си, и с тех пор присутствуют во всех языках с си-подобным синтаксисом.
4. Функции
   Сейчас мы подошли к важнейшему понятию программирования – функции. Важнейшему потому, что функции являются строительными блоками любой программы, и в терминах функций думают о программах программисты. И все это оттого, что функция является абстракцией самого алгоритма вычислений, она отделяет алгоритм от данных, над которыми он выполняется. 
  Определение функций
   Рассмотрим программу, которая вычисляет факториал заданного числа n. 
   
// установка параметра
var n = ???;

// вычисление n!
var f = 1;
for (var i = 1; i <= n; i += 1)
   f *= i;

// вывод результата
alert(f);
   В программе три части: задание параметра, подсчет факториала и вывод результата. Только вторая часть выполняет вычисления, ей-то мы и придадим форму функции.
   
function factorial(n) 
{
   var f = 1;
   for (var i = 1; i <= n; i += 1)
      f *= i;
   return f;
}
То, что написано выше, является определением функции. Определение состоит из заголовка 
   
function factorial(n) 
и тела функции.

{
   var f = 1;
   for (var i = 1; i <= n; i += 1)
      f *= i;
   return f;
}
   Заголовок начинается с ключевого слова function, за которым следует имя функции (имя мы придумываем сами, как придумывали имена переменных) и перечень параметров в круглых скобках. У функции factorial один параметр, но мы по опыту знаем, что параметров бывает и больше, так у программы вычисления синуса было два параметра.
   В отличие от параметров программы, которые носили у нас неформальный характер, параметры функции имеют свое законное место – за именем функции в круглых скобках.
   В теле функции мы видим новую команду, состоящую из ключевого слова return и следующего за ним выражения, заключающего в себе результат вычислений. Как только интерпретатор выполнит команду return, он покинет тело функции и вернется к программе, которая вызвала функцию, ведь return означает возврат. 
   Когда интерпретатор просматривает определение функции, он не выполняет никаких вычислений. Чтобы вычисления начались, функцию нужно вызвать. 
   Вот как выглядит наш код, после того, как мы вынесли вычисление факториала в отдельную функцию.
   
// определение функции
function factorial(n) 
{
   var f = 1;
   for (var i = 1; i <= n; i += 1)
      f *= i;
   return f;
}

// основная программа
var n = 6;
var y = factorial(n);  // вызов функции
alert(y);
   Вызов функции – это выражение, состоящее из имени функции и аргумента в круглых скобках, например, factorial(n). В математике аргумент – это то, к чему применяется функция, в программировании – то же самое. 
   Выполняя вызов функции, интерпретатор сначала вычислит значение выражения-аргумента, затем присвоит это значение параметру функции, и лишь потом зайдет в тело функции и будет выполнять его, пока не встретит команду return. Тут он вернется в основную программу с результатом вычислений (помните, выражение за словом return). Этот результат он подставит вместо вызова функции и продолжит работу. В нашем примере в команде 
       var y = factorial(n);  
вместо factorial (n) интерпретатор подставит число 720 и продолжит работу, т.е. присвоит 720 переменной y.
   Порядок действий интерпретатора при вызове функции является частью модели вычислений
   
   Подведем промежуточный итог. 
1. В программе можно определять функции – одну, две, сколько угодно.
2. Определение функции состоит из заголовка и тела. В заголовке находится имя и параметры, в теле – код вычислений.
3. Результат вычислений возвращается вызывающей программе командой return.
4. Чтобы заставить функцию работать, ее надо вызвать, само по себе определение функции ничего не делает.
5. Вызов функции – это выражение, значением которого является то, что вернет функция.
  Примеры функций
   Пример 1. Функция, которая возвращает большее из двух чисел.

function max(a, b) 
{
   if (a > b) 
      return a;
   else 
      return b;
}
   У функции max два параметра, a и b. Команд возврата (по случайному совпадению) тоже две. Поскольку команда return немедленно возвращает интерпретатор в вызывающую программу, код можно написать и так.
       
function max(a, b) 
{
   if (a > b) 
      return a;
   return b;
}
   Пример 2. Функция, которая возвращает большее из трех чисел.
       
function max3(a, b, c) 
{
   return max(max(a, b), c);
}
   Да! Функцию можно вызывать из другой функции, а не только из основной программы. 
   Как должны располагаться в файле определения функций max и max3, что должно быть раньше, а что потом? Интуиция подсказывает, что сначала должно быть дано определение функции max, ведь функция max3 ее вызывает. 
   На самом деле порядок следования определений роли не играет. Дело в том, что интерпретатор просматривает код программы дважды. При первом просмотре он запоминает определения функций и переменных, при втором выполняет основную программу. Те команды, что содержатся в определении функции, будут выполняться, только когда функцию вызовут.
   
   Пример 3. Функция, которая выводит слова “Hello, world!”.

function hello() 
{
   alert("Hello, world!");
}
   У этой функции совсем нет параметров – и такое бывает. Тем не менее, в заголовке присутствуют круглые скобки, их требуют правила языка. 
   Функция hello ничего не возвращает в вызывающую программу, и в ней нет команды return. Если в теле функции нет команды возврата, интерпретатор покинет ее тело, когда выполнит последнюю из команд. Если мы по какой-то причине хотим закончить выполнение раньше, можно написать команду return без последующего выражения.
   Что будет, если мы все же напишем
       var x = hello(); 
 Переменная х примет значение undefined.

4.1. Определите функцию, которая получает два числа и возвращает их среднее арифметическое.
4.2. Определите функцию, которая вернет значение наименьшего из трех чисел. У функции должно быть три параметра.
4.3. Есть три числа: a, b и c. Нужно вычислить сумму кубов двух меньших чисел. Для этого определите функцию с тремя параметрами.
  Передача аргументов в функцию
   Попытаемся определить функцию, которая меняет местами значения двух своих параметров. 
   
function swap(a, b) 
{
   var t = a;
   a = b;
   b = t;
}
   Такая функция сократила бы код многих программ – вместо того, чтобы писать три команды присваивания, мы бы писали одну команду вызова функции.

var x = 3, y = 5;
swap(x, y);  // хотим выполнить обмен
alert(x);    // 3 
alert(y);    // 5
   Увы, наша надежда не оправдалась. Причина в том, что при вызове функции аргументы присваиваются ее параметрам, вот так: 
   a = x; 
   b = y; 
   Нам известно, что для чисел работает простая модель вычислений, в которой присваивание – это копирование. Следовательно, в переменных a и b находятся копии значений из x и y, и все действия в теле функции происходят не над переменными x и y, а над их двойниками.
   Мы помним, что исполняя команду вызова, интерпретатор сначала вычисляет значения аргументов, а потом присваивает первый аргумент первому параметру, второй – второму, и т.д. Что произойдет, если вызвать функцию с меньшим числом аргументов, чем число ее параметров? 
   Параметры, которым не достанется значений, останутся undefined. 
   Что будет, если вызвать функцию с большим числом аргументов, чем число ее параметров? 
   Лишние аргументы интерпретатор проигнорирует.
   
   Пример 4. Обобщим функцию max таким образом, чтобы можно было вызывать ее с переменным числом аргументов, от одного до трех.
   
function max(a, b, c) 
{
   // часть 1
   if (b == undefined)
      return a;
   if (a > b)
      b = a;

   // часть 2
   if (c == undefined)
      return b;
   if (b > c)
      c = b;

   // эпилог
   return c;  
}
   В первой части решения проверяем, не задан ли функции только один аргумент (b = undefined). Если это так, то он и есть максимальный. Если же аргументов два или более, придаем второму большее из двух первых значений, чтобы забыть о первом аргументе навсегда и дальше действовать так, будто второй аргумент – первый.
   Именно поэтому вторая часть решения копирует первую с точностью до обозначений параметров, все обозначения «сдвинулись» на шаг вправо.
   Это лишь одно из возможных решений. Оно состоит из двух похожих частей, и его легко распространить на большее количество аргументов.
   
4.4. Определите функцию max(a, b, c, d, e), которую можно вызывать с любым числом аргументов, от одного до пяти.
4.5. Определите функцию sum(a, b, c, d, e), которая просуммирует любое количество своих аргументов, от одного до пяти.
  Локальные переменные
   Вернемся еще раз к функции factorial.
   
function factorial(n) 
{
   var f = 1;
   for (var i = 1; i <= n; i += 1)
      f *= i;
   return f;
}
   В ее теле определены переменные f и i. За пределами тела функции эти переменные не видны, поэтому говорят, что определение функции создает область видимости, а переменные f и i называют локальными. В противоположность локальным,  имена переменных и функций, которые определены в основной программе, называют глобальными.
   То, что каждое определение функции создает отдельную область видимости,  большое благо для программистов – они могут выбирать любые имена для локальных переменных, не боясь вступить в конфликт с другими именами в программе.
   Нужно только не забывать писать слово var перед первым упоминанием имени локальной переменной. Дело в том, что по правилам JS переменные, объявленные без слова var, считаются глобальными со всеми вытекающими последствиями.
   
   Пример 5. Выведем поочередно в окно alert факториалы чисел 5, 10, 15, 20 и 25. Сделаем это при помощи команды повторения.
   
for (var f = 5; f <= 25; f += 5)
   alert(factorial(f));

function factorial(n) 
{
   var f = 1;
   for (var i = 1; i <= n; i += 1)
      f *= i;
   return f;
}    
   Все замечательно работает. Теперь "забудем" написать  слово var в определении переменной f функции factorial.
   
 var f = 1;
   Программа работать перестала. И это не удивительно, т.к. интерпретатор посчитал, что имя f в теле функции и имя f в основной программе обозначают одну и ту же переменную.
  Библиотеки функций
   Как только программисты стали писать программы, сразу встал вопрос об их повторном использовании. Первой начала собирать полезные программы Грэйс Хоппер – вторая (хронологически) программистка после Ады Лавлейс.
   Историческая справка
   Грейс Хоппер (1906–1992) – американский математик и контр-адмирал флота США. Писала программы для первых американских электромеханических компьютеров Mark-1 и Mark-2. Во время второй мировой войны поступила на службу в ВМФ США в чине младшего лейтенанта. Написала первый компилятор с языка математических формул на машинный язык . 
   В 50-х годах руководила проектом по созданию языка COBOL (Common Business Oriented Language), который применяется и сейчас.
   
   Очень скоро эти повторно используемые программы приобрели вид функций, и тематические собрания функций стали называть библиотеками.
   Свою библиотеку функций имеет и JS. Если программы JS выполняются в браузере, в распоряжение программиста поступает еще и библиотека браузера. 
   Функции в библиотеке не свалены в одну кучу, а распределены по объектам. Например, функции sqrt, abs, pow и ряд других математических функций принадлежат объекту Math. Их вызывают с указанием имени объекта:   Math.sqrt(x), Math.abs(y), Math.pow(x,y).  
   Сейчас настал момент открыть истину и признаться, что alert не команда языка JS, а имя функции из библиотеки браузера. Функция alert не возвращает никакого значения (или возвращает undefined, как вам больше нравится). Польза от вызова подобных функций не в получении нового значения, а в тех действиях, которые они совершают в ходе своего выполнения. Действие функции alert состоит в том, что она открывает окно, в котором появляется значение ее аргумента. 
   Как всякая функция, alert приписана к объекту, и называется этот объект window. Почему же мы писали alert(x), а не window.alert(x) ?
   Дело в том, что window особый объект – корневой. По правилам JS функции корневого объекта можно вызывать без указания его имени (но можно и с указанием). Разумеется, корневой объект только один, и во всех браузерах он зовется window. 
   А к какому объекту интерпретатор приписывает функции, которые определяем мы сами? Ответ ясен – к объекту window, ведь мы вызываем их без имени объекта.
   Нелишне заметить, что если JS исполняется не в браузере, то корневой объект, скорее всего, будет другим и у него не будет функции alert().
  Абстракция и декомпозиция
   Абстракция и декомпозиция это два кита (или слона?) на которых держится все программирование. 
   Абстракцией было присвоение имен выражениям – имя скрывало структуру выражения и представляло его в целом. Абстракцией была модель памяти в виде пронумерованных ячеек и модели вычислений, вообще любая модель – абстракция. Схемы команд, которые задают их синтаксис – тоже абстракция. И множество абстракций нас ожидают впереди. 
   Декомпозиция заключается в разбиении задачи на подзадачи, чтобы по частям решить то, что в целом кажется неразрешимым.
   Функция одновременно является продуктом абстракции – вычисления отделяются от данных, и инструментом декомпозиции – программа для решения задачи в целом состоит из функций, решающих отдельные подзадачи. И это тоже делает ее уникальной.
  Заключение
1. Функция – краеугольное понятие программирования. Мы определяем в программе собственные функции, и из этих определений состоит наш программный код.
2. Перед выполнением тела функции аргументы вычисляются и присваиваются параметрам.  Параметры делаются копиями аргументов.
3. Как правило, задача функции – выработать и вернуть в вызывающую программу новое значение. Но бывают функции, которые ничего не возвращают, а лишь воздействуют на свое окружение. Такое воздействие называют побочным эффектом.
4. Любую функцию, как пользовательскую, так и встроенную, можно расценивать как расширение множества команд алгоритмического языка. Ранее мы считали встроенную функцию alert командой, и теперь понимаем, что не так уж и ошибались.
5. Определение функции создает отдельную область видимости. Все, что объявлено внутри функции, включая параметры, не видно извне. Все, что объявлено в основной программе, видно и в теле функции. Определение функции как бы создает оболочку, прозрачную изнутри и непрозрачную извне.
5. Строки
   Всем известно, что пользователи компьютеров в основном нагружают их не математическими вычислениями, а работой с текстом. Это должно повысить наш интерес к строкам, так как строки – это программное воплощение текста. 
  Строковые константы
   Мы уже видели строки, мы выводили их в окно функцией alert. То, что мы видели, называется строковыми константами, точнее, литеральными строковыми константами. 
   Вообще, литеральные константы – это такие значения, вид которых говорит сам за себя, т.е. из которых видно, что именно они обозначают. Например, 8 или 1.25 – это литеральные числовые константы, а "Брендан Айк" – литеральная строковая константа. 
   В противовес литеральным бывают символические константы, когда постоянным величинам присваивают какие-то имена. В коде символические константы предпочтительней литеральных, т.к. им можно придать «говорящий» вид.

MAX_VALUE = 31;  
GAMMA =  6.67385E-11;
HOST_NAME = "localhost";
   Важно и то, что программы с символическими константами легче поддаются переделке, т.е. рефакторингу.
   К сожалению, JS не допускает символических констант (по крайней мере, в его текущей версии, ECMAScript 5), но между программистами существует соглашение, чтобы фактически неизменяемым значениям давать имена из прописных букв и знаков подчеркивания. Такие имена должны сигнализировать о том, что эти переменные исполняют в программе роль символических констант. 
   Итак, литеральные строковые константы – это последовательности любых символов, заключенные в двойные или в одинарные кавычки. Зачем такой либерализм? Чтобы можно было включить в строку и кавычки тоже. Например, "з'ясували" или 'Никогда не говори "никогда" '. 
   А если мы захотим включить в строку оба типа кавычек? Тут нам поможет экранирующий символ (escape character). Таким символом в JS является обратный слеш «\». Экранирующий символ изменяет способ интерпретации символа, следующего за ним. 
   В стандартной интерпретации кавычки и обратный слеш являются управляющими символами, а все прочее – просто символы, как есть.  Экранирующий символ перед кавычками и слешем делает их просто символами, а обычные символы превращает в управляющие. Например, сочетание \n означает новую строку, \t – знак табуляции, \b – забой. Те же символы, которым не досталось управляющих функций, и со слешем интерпретируются стандартно, т.е. как есть. 
   
alert('anz');        // anz
alert('\a\n\z');     // буквы a и z в разных строках
alert('C:\\root\\foo.txt');   // C:\root\foo.txt
   Строковые константы можно присваивать переменным
   
var brendan = "Брендан Айк";
и передавать в функции. 

alert('Привет');
   Их можно сравнивать на совпадение (==), несовпадение (!=) и всеми другими способами ( <, >, <=, >=).

alert('abc' < 'abd');   // true
alert('ab' < 'abc');    // true
alert('xyz' <= 'xyz');  // true
   Сравнение строк лексикографическое, т.е. если все возможные строки мысленно выстроить в алфавитном порядке, меньшими будут те, которые в таком строю стоят раньше. 
  Методы строк
   Мы видим, что со строковыми константами можно делать многое, но как получать из них новые строки?
   Новые строки можно составлять из старых, соединяя их операцией «+». В результате получится новая строка, а исходные строки останутся без изменений.
   
var s = "Hello " + "World.";
alert(s);    // Hello World.
   В данном примере + не арифметическая операция, а операция над строками. Некоторые лексемы JS имеют разный смысл в зависимости от контекста (т.е. от своего окружения). Если знак + стоит между двумя числами, интерпретатор их просуммирует. Если тот же знак стоит между двумя строками, интерпретатор соединит две строки в одну. 
   Другим источником новых строк являются методы строк. Методы – это функции, принадлежащие объектам. Как мы увидим позднее, строки – род объектов, а значит, у них могут быть методы. Методы вызывают с указанием объекта, которому они принадлежат.
   
объект.метод(аргументы);
   Этих пояснений пока достаточно, чтобы пользоваться методами строк. Более точную картину мы увидим, когда познакомимся с объектами.
   
   Начнем с метода charAt. Он позволяет получить один символ строки по его порядковому номеру (нумерация символов строки ведется слева направо и начинается с нуля). Результат метод возвращает в виде новой строки длиною в один символ.
   
var str = 'JavaScript';
var s = str.charAt(2);   
alert(s);     // v
Замечание. В современных браузерах n-й символ строки s можно получить проще: s[n].

var str = 'JavaScript';
alert(str[2]);   // v
   Объектам могут принадлежать не только функции, но и переменные, вспомним Math.PI. Принадлежащие объектам переменные называют свойствами. 
   Все строки обладает свойством length, которое показывает количество символов в строке.

var s = 'JavaScript';
alert(s.length);     // 10
   Попробуем применить полученные знания.
   Пример 1. Определить функцию, которая получает строку и возвращает другую строку, в которой символы исходной строки расположены в обратном порядке. 

function reverse(s) 
{
   var result = '';
   for (var i = 0; i < s.length; i += 1)
      result = s[i] + result;   
   return result;
}
Работа сделана – функция объявлена. Если мы хотим ее проверить, нужно вызвать функцию с различными аргументами.

alert(reverse('12345'));
alert(reverse('1'));
alert(reverse(''));   // пустая строка – тоже строка
5.1. Определите функцию count, которая получает строку и символ (т.е. строку из одного символа). Функция должна определить, сколько раз заданный символ встречается в заданной строке.
5.2. Определите функцию palindrome, которая получает строку и возвращает 1, если строка является палиндромом, и 0 в противном случае. Палиндромом называется строка, которая одинаково читается в обоих направлениях, например, «топот», «потоп», «нажалкабаннабаклажан».
   
   Подстрокой будем называть строку, которая целиком содержится в другой, более длинной строке. Например, подстроками строки «компакт» являются:  «пакт»,  «ком» или «комп».
   Метод indexOf осуществляет поиск вхождения подстроки в строку. Он возвращает позицию, с которой подстрока начинается в строке.
   
var str = 'компакт';
var n = str.indexOf('пакт');
alert(n);   // 3
   Если подстрока входит в строку неоднократно, будет определена позиция первого вхождения. Если вхождений вообще нет, метод вернет 1. Число 1 не может быть номером символа в строке, поэтому пригодно для индикации отсутствия вхождений. 
   У метода indexOf есть второй, необязательный параметр, который указывает, с какой позиции начинать поиск.

var str = 'тригонометрия';
alert(str.indexOf('три'));     // 0 
alert(str.indexOf('три', 1));  // 9
5.3. Определите функцию, которая получает строку и подстроку и подсчитывает число вхождений подстроки в строку. Считаются только не пересекающиеся вхождения, т.е. подстрока 'aaa' входит в строку 'aaaaaa' два раза, а не четыре. 
5.4. Определите функцию, которая находит позицию последнего вхождения подстроки в строку. Если вхождений нет, функция возвращает -1.

   Метод substr вырезает из строки подстроку заданного размера. Первый параметр метода задает стартовую позицию вырезки, второй, необязательный, – ее длину.
       
var str = 'тригонометрия';
alert(str.substr(7, 4));    // метр
alert(str.substr(7));       // метрия
5.5. Определить функцию, которая получает два слова, например, «комар» и «кошмар». Если введенные слова рифмуются, функция возвращает 1, если не рифмуются, 0. Не углубляясь в стихосложение, будем считать, что слова рифмуются, если у них совпадают последние три буквы или если одно из слов является окончанием другого.
5.6. Слово называется анаграммой, если оно является результатом перестановки букв другого слова. Объявить функцию, которая получает два слова и возвращает 1, если слова являются анаграммами друг друга. В противном случае функция должна вернуть 0.
  	Заключение
1. Поддержка строк в JS выражается в наличии литеральных строковых констант – последовательностей символов, заключенных в одинарные или двойные кавычки.
2. Над строками определена операция соединения, которая кодируется знаком +. Несмотря на совпадение обозначений, сложение чисел и соединение строк – абсолютно разные операции.
3. У строк есть методы – функции, которые принадлежат строкам. Методы предоставляют нам базовые операции над строками. Комбинируя базовые операции, программист может определять свои собственные. 
6. Типы данных
   Мы уже много знаем о числах и строках, и кое-что знаем о логических значениях. Сначала пополним наши знания о последних, а затем подведем промежуточный итог всему изученному.
  Логический тип данных
   До сих пор логические выражения встречались нам в условиях команд if, while, for. Выражения состояли из сравнений и чисел. Числа в качестве условий интерпретировались как «истина» (все числа, не равные нулю) или «ложь» (число 0, NaN и undefined). Сравнения вырабатывали те же два значения, «истина» и «ложь».
   Посмотрим, как функция alert покажет нам эти значения.
   
alert(0 < 1);   // true
alert(0 > 1);   // false
   Наряду с числовыми и строковыми, JS различает еще один – булевский (или логический) тип значений. В чем-то он похож на числовой тип, но отличается тем, что логических значений мало – всего два.  Сходство же в том, что оба типа имеют литеральные константы, их значения можно сравнивать и выполнять над ними похожие операции.
   Историческая справка
   Джордж Буль (1815–1864) – английский математик и логик. Был женат на Мэри Эверест, племяннице географа Эвереста, в честь которого названа самая высокая на земле гора (8844 м). 
   Буль показал, как из любого числа высказываний, включающих любое число терминов, можно вывести заключение, следующее из этих высказываний, путём чисто символических манипуляций. Это он ввел два логических значения (ложь и истина) и три операции над ними (И, ИЛИ, НЕ). Его именем назван логический тип данных во многих языках программирования, в том числе в JS. 
  Логические операции
   Если условия формулировать словесно, то логические операции будут связками между простыми предложениями. Основных связок три: И, ИЛИ, НЕ. 
   Например, «x > 0 И x < 10». Такое условие истинно, если истинны оба простых условия, из которых оно составлено. Если хотя бы одно из простых условий ложно, то и составное условие будет ложным. 
   То, что логических значений всего два, позволяет задать логическую операцию И (в JS она обозначается двойным амперсандом – &&) в виде таблицы.
   
X      Y      X&&Y
false  false  false
false  true   false
true   false  false
true   true   true
   Таблица выражает то, что мы уже знаем об этой операции, но в строгой форме.  
   
Пример 1. Запишем условие принадлежности числа x отрезку [0, 10].
   
if (x >= 0 && x <= 10)
   alert ("x in [0, 10]");
Пример 2. Есть три переменные: Small, Middle и Big. Если их значения соответствуют их названию, т.е. Small < Middle, и  Middle < Big, вывести “Wow!”, а если нет, вывести “Opps”.

if (Small < Middle && Middle < Big)
    alert("Wow!");
else
    alert("Opps.");
   Связка ИЛИ образует условие, которое истинно, если истинно хотя бы одно из двух входящих в него условий. Например, «x > 10 ИЛИ x < -10». В программах на JS операция ИЛИ обозначается двойной вертикальной чертой – ||. 
   Таблица логической операции ИЛИ такого же размера, как таблица операции И.
   
X      Y      X||Y
false  false  false
false  true   true
true   false  true
true   true   true
Таблицы для И и ИЛИ отличаются всего в двух клетках, и это отличие вы, несомненно, найдете.
Операцию И часто называют логическим умножением, а операцию ИЛИ логическим сложением. Нетрудно догадаться, почему, если заменить false нулем, а true единицей.

X     Y    X&&Y                    X     Y    X||Y
0     0      0                     0     0      0
0     1      0                     0     1      1
1     0      0                     1     0      1
1     1      1                     1     1      1
Таблица для И в точности совпадает с таблицей умножения чисел, таблица для ИЛИ напоминает таблицу сложения.

   Пример 3. Переменные a, b и c хранят числа. Ответить, можно ли из этих чисел как-нибудь составить арифметическую прогрессию?
   "Как-нибудь" означает произвольный порядок следования чисел a, b и c. Хотя всего вариантов следования шесть, их можно рассматривать попарно, так если (a, b, c) – прогрессия, то (c, b, a) – тоже прогрессия. Остается рассмотреть три возможности:  (a, b, c),  (b, a, c), и  (a, c, b). Если прогрессию составить можно, то хотя бы в одной тройке сумма крайних чисел равна удвоенному среднему числу.
   
if (a + c == 2 * b || b + c == 2 * a || a + b == 2 * c)
   alert("Есть прогрессия.");  
   Остается разобраться с операцией НЕ, которая в разговорной речи означает отрицание. Т.е. если условие X истинно, то условие НЕ X ложно, и наоборот. В программном коде операция НЕ обозначается восклицательным знаком и задается следующей таблицей.
   
X      !X
false  true
true   false
   Пример 4. Есть два числа, a и b. Если оба они равны нулю, вывести слово "Cancel", иначе вывести слово "OK".
   
if (!a && !b)
    alert ("Cancel");
else
    alert ("OK");
6.1. Есть три переменные. Проверить, могут ли их значения быть длинами сторон треугольника. Проверку должна выполнять функция, которая получает три числа и возвращает логическое значение.
6.2. Есть три целых числа. Проверить, могут ли эти числа быть длинами сторон прямоугольного треугольника.
6.3. Пройдет ли кирпич со сторонами a, b, c в прямоугольное отверстие со сторонами x, y? 
6.4. Взять сравнение "x < y" и при помощи логических операций выразить через него пять других сравнений, например, сравнение x >= y можно записать как !(x < y).
  Простые типы данных
   Итак, мы знаем уже три типа данных: числовой (Number), строковый (String), логический (Boolean). Четвертым типом считается тип, содержащий единственное значение undefined, и зовут его Undefined. Данные разных типов по-разному выглядят, а главное, допускают над собой разные операции. Даже если некоторые операции одинаково обозначаются (вспомните сложение чисел и соединение строк), они различны по своей природе. Можно сказать, что тип данных – это множество возможных значений плюс набор допустимых операций над этими значениями. 
   Перечисленные четыре типа не исчерпывают всех типов JS, но их объединяет неизменность значений и простая модель вычислений. Неизменность значений выражается в том, что мы не можем менять отдельные разряды числа или некоторые символы строки, но можем создать новое число или новую строку, такую, как нам нужно. 
   Типы Number, String, Boolean и Undefined относятся к простым типам JS. Кроме простых, существуют составные типы, ими мы вскоре займемся.
  Преобразования типа
   Все операции подразумевают определенный тип операндов, вспомните арифметические действия или соединение строк. Нет никакого смысла в сложении строки с числом: "abc" + 123. Попробуем.
   
alert("abc" + 123);   // abc123
   Гм, интерпретатор, оказывается, другого мнения. В чем же дело?
   Дело в том, что интерпретатор сам преобразовал числовое значение в строковое, и уже после этого выполнил операцию соединения строк.
   Кто просил его? Никто. Просто разработчики JS предполагали, что мы пишем программы, чтобы получить результат, а не для того, чтобы морочить интерпретатор.
   «Преобразовал значение», это общеупотребительное выражение. На самом деле интерпретатор создал новое значение иного типа, а не трансформировал старое, но к термину уже привыкли.
   Если мы не хотим полагаться на интерпретатор, то должны сами выполнить необходимые преобразования. Всего есть три вида преобразований: в число, в строку и в булевский тип. Все они выполняются при помощи функций, имена которых совпадают с именем типа: Number, String, Boolean.
   
alert( Number("123") + 456 ); // 579

alert( String(123) + 456 );   // 123456

alert( Boolean(1) );          // true
   Замечание. Не нужно забывать, что когда мы смотрим на результат вывода, мы видим не содержимое памяти, а лишь то, что нам показывает функция alert. Если аргумент функции alert не является строкой, она преобразует его в строку.
  Неявные преобразования
   Разговор о преобразовании типа мы начали с примера неявного преобразования.
   
alert("abc" + 123);   // abc123
   Результат явных преобразований очевиден, результат неявных можно предсказать, только если знаешь правила. Эти правила точно не самая понятная часть JS, и мы рассмотрим только основные из них.
   Неявное преобразование в строку
1. Происходит, когда «складываются» строки с не строками.
2. Выполняется функцией alert.
   Неявное преобразование в число
1. Происходит в выражениях и математических функциях.
   
alert("20" * 5); // 100
alert("20" - 5); // 15
   Это, однако, не касается операции «+».
   
alert("20" + 5); // 205
   Помочь горю можно, поставив унарный плюс перед строкой.
   
alert(+"20" + 5); // 25
2. Происходит при сравнении чисел с не числами.

alert("20" > 3);   // true
alert("20" > "3"); // false
В первой команде произошло неявное преобразование строки в число. Во второй команде сравнивались две строки, преобразования типа не было.
   
   Неявное преобразование в булево значение
   Оно происходит, когда строки или числа встречаются в составе логических выражений.
1. Числа 0 и NaN преобразуются в false, прочие числа – в true.
2. Пустая строка – это false, все прочие строки – true.
3. Значение undefined – это false.
Проверить это можно при помощи все той же функции alert, передавая ей различные значения, включенные в состав логического выражения. Подходящим логическим выражением является двойное отрицание, !!x, оно короткое и равно своему аргументу.

alert(!!"");   // false
alert(!!"0");  // true
alert(!!0);    // false
alert(!!-1);   // true
   Мы не охватили все случаи неявного преобразования. Например, мы не сможем объяснить, почему первая команда выведет false, а вторая true?
   
alert(false == !!"0");   // false
alert(false == "0");     // true
   Оказывается, в первом случае сравнивались две однотипных значения (false == true), а во втором – разнотипные, поэтому они оба были преобразованы к числам (0 == 0).
   В общем, если вы решили выполнять в своих программах только явные преобразования, то приняли хорошее решение.
  Строгие сравнения
   Как выяснилось, при сравнении разнотипных величин происходит неявное преобразование. 
   
var x = 0;
alert(x == false);  // true
   К счастью, в JS можно сравнить значения оператором === (три знака равенства), заблокировав преобразования типа. При этом никакие разнотипные величины не будут считаться равными.
   
alert(x === false);  // false
   Если вы знаете, что сравниваемые значения одного типа, применяйте строгие сравнения: === и !==. Этим вы застрахуете себя от неожиданностей. 
  Заключение
1. Логический тип данных во многом подобен числовому. Логические значения можно присваивать переменным и составлять из них выражения.
2. Нам известны четыре типа данных: числовой, строковый, логический и неопределенный. Все они относятся к простым типам и подчинены простой вычислительной модели.
3. Возможно преобразование значения одного типа в значение другого типа. Это можно сделать явно или неявно. 
4. Строгие сравнения блокируют неявное преобразование типа. Этим нужно пользоваться.
7. Объекты
   Простые типы JS позволили нам написать множество разных программ. Но простые типы недостаточно выразительны. Чтобы выразить в программе такое понятие как «треугольник на плоскости», нам понадобилось бы шесть переменных, задающих координаты его вершин. Любые операции с треугольниками – присваивание, вывод, копирование, масштабирование потребовали бы многих строк кода. 
   Понятие «многоугольник» вообще нельзя выразить с помощью одних только простых типов. 
   Нам пора подняться на еще один уровень абстракции и заняться составными типами данных, главным из которых является тип Object.
  Объекты это контейнеры
   Объект может содержать в себе произвольное количество простых значений и даже других объектов. Если простая переменная это ячейка с именем, то объект это контейнер, в котором может храниться множество отдельных ячеек и даже других контейнеров.
   Пример 1. Создадим объект и поместим в него две ячейки: с числом и строкой.
   
var cont = new Object();
cont.num = 123;
cont.str = "строка";
   
   
   Рисунок 7.1 – Контейнер с ячейками
   
   По скобкам после имени можно догадаться, что Object() – это вызов функции. Если вызову функции предшествует зарезервированное слово new, то функция сконструирует объект и вернет его в вызывающую программу. Таким образом, функция Object является конструктором объектов.
   В результате выполнения первой команды 
   
var cont = new Object();
будет создан новый объект и присвоен переменной cont. 
   Вторая и третья команды добавляют в объект одно строковое и одно числовое значение. Переменные  cont.str и cont.num называются свойствами объекта. 
   
   Пример 2. Создадим объект с тремя свойствами: year, month и day.
   
var date = new Object();
date.year = 2015;
date.month = "Май";
date.day = 1;
   Легко догадаться, что объект date хранит календарную дату «1 мая 2015 года». 
   Объекты так важны, что для работы с ними JS имеет особый синтаксис, облегчающий работу с объектами. Вот как выглядит создание объекта из примера 1.
   
var cont = {num: 123, str: "строка" };
   А это создание объекта из примера 2.
   
var date = {year: 2015, month: "May", day: 1};
   Такая нотация объясняется тем, что объекты в JS рассматриваются как множество пар имя: значение. Фигурные же скобки в математике означают множество. Внутри одного объекта имена не могут повторяться. Согласитесь, что объект напоминает множество имен и значений переменных в программе или в теле функции.
   Объекты часто называют словарями. Объект и в самом деле похож на словарь, в котором имена свойств – это слова, а значения – их толкование. 
   Еще одно прозвище объекта – ассоциативный массив, потому, что значения в нем ассоциированы с именами свойств. Зная имя, можно тотчас получить значение.
   
alert(cont.num);   // 123
alert(cont.str);   // строка
   Так же быстро мы можем вспомнить что-то по ассоциации. 
   Сконструировать пустой объект можно так.
   
var date = {};  
   Именами свойств могут быть любые строки, например, "день недели", "0", "1234". Если имена свойств объекта не являются в то же время именами JS, обращаться к свойствам можно только при помощи квадратных скобок.
   
var date = 
   {"год": 2015, "месяц": "May", "день месяца": 1};

alert(date["день месяца"]);
  Манипуляции со свойствами
   Свойства можно не только добавлять в объект, но и удалять из него командой delete.
   
   Пример 3. Объект «окрашенный прямоугольник».
   
var rect = {width: 10, height: 12, color: "red"};
alert(rect.color);  // red
delete rect.color;  
alert(rect.color);  // undefined 
   Убедиться в существовании свойства у объекта можно, сравнив свойство с undefined.
   
alert(rect.color === undefined);  
   или 
   
alert(rect["color"] === undefined);  
   Для перечисления свойств объекта в JS имеется специальная команда повторения – for-in.
   
var rect = {width: 10, height: 12, color: "red"};
for (var p in rect) {
   alert(rect[p]);
}
Свойства перечисляются в том порядке, в каком они были добавлены в объект. Но, как мы увидим позже, из этого правила есть исключение, оно касается массивов.

7.1. Имеется объект rect (прямоугольник) со свойствами width и height. Определите его площадь.
7.2. Соберите в одну строку имена всех свойств объекта window. Разделителем имен сделайте вертикальную черту, ' | '.
7.3. Создайте пустой объект obj и снабдите его 10-ю свойствами с именами p1, p2,…, p10 и значениями 'v1', 'v2',…, 'v10'. Для добавления свойств используете цикл for и нотацию с квадратными скобками.
7.4. Удалите из объекта obj все свойства с четными номерами.
  Ссылочная модель вычислений
   Еще в первом разделе книги мы рассмотрели простую модель вычислений. В этой модели значения сменяли друг друга в именованных ячейках. Простая модель применяется для простых типов, но не для объектов.
   Разберем, что происходит, когда выполняется присваивание такого вида.
   
var date1 = {year: 2015, month: "May", day: 1};
   Выражение в правой части присваивания конструирует объект с тремя свойствами, year, moth, day, и задает значения этих свойств. Вновь созданный объект размещается в свободном участке памяти, а в ячейку с именем date1 помещается адрес участка. 
   
   Замечание. Адрес участка памяти – это номер первой ячейки участка. 
   
   Рисунок 7.2 – Ссылка на объект
   
   
   Благодаря адресу в переменной date1, интерпретатор сможет быстро найти объект, когда понадобится обратиться к его свойствам: date1.year, date1.month и т.п. Говорят, что переменная date1 ссылается на объект, отсюда – ссылочная модель вычислений.
   Отличие ссылочной модели от простой в том, что когда выполняется присваивание, в переменную помещается не сам объект, а лишь его адрес. В результате следующего присваивания
   
var date2 = date1; 
   один и тот же адрес будет находиться и в переменной date1, и в переменной date2. Поэтому ссылаться на объект теперь можно и по имени date1, и по имени date2. 
   
   
   Рисунок 7.3 – Две ссылки на объект
   
   Вот подтверждение этого.

date2.year = 2016;
alert(date1.year);  // 2016
   Можно назвать имена date1 и date2 синонимами, т.к. они обозначают один и тот же объект.
   
   Рассмотрим другой случай.

var rect = { width: 100, height: 200, color: "red" };
rect = { width: 2, height: 3, color: "black" };
   Вначале был создан один прямоугольник, и его адрес записан в переменную rect. Потом создали другой прямоугольник, и его адрес записали в ту же переменную. Адрес первого прямоугольника исчез безвозвратно, хотя сам прямоугольник еще находится в памяти.
   


   Рисунок 7.4 – Одна ссылка и два объекта
   
   Объекты без ссылок недоступны в программе, а значит, бесполезны. Они обнаруживаются и удаляются из памяти специальной службой интерпретатора, которая называется сборщиком мусора. Освобожденная память будет использована для размещения новых значений.
   Наличие автоматической сборки мусора снимает с программиста ответственность за освобождение памяти и делает процесс программирования более приятным и производительным. Напротив, ручное управление памятью может сделать более производительными сами программы. 
   В зависимости от того, чья производительность важнее, выбирают языки со сборкой мусора или без нее. Для прикладного программирования применяют языки со сборкой мусора (JS, Java, C#, Python, Lisp), для системного программирования – языки без сборки мусора (С, C++, Assembler). 

7.5. Есть объект obj, обладающий несколькими свойствами простых типов. Создайте объект obj2, его точную копию. Для этого создайте пустой объект и снабдите его свойствами, которые скопируйте у obj.

   Простая модель хорошо подходит для чисел и логических значений, т.к. они занимают мало места, и поэтому их легко копировать. Иначе обстоит дело со строками, они могут быть очень длинными. Как же простая модель работает для строк? Ответ – никак, строки подчиняются ссылочной модели. 
   Дело в том, что для неизменяемых значений обе модели, простая и ссылочная, дают одни и те же предсказания. Иными словами, мы не сможем опытным путем установить, какой модели подчиняется неизменяемые значения, простой или ссылочной. Наряду с числами строки – значения постоянные, их поведение одинаково правильно будет объясняться и ссылочной, и простой моделью, и потому строки отнесены к простым типам.
   
   
   В отличие от строк, объекты – значения изменяемые. Однажды создав объект, мы можем изменять его отдельные части – свойства. Для объектов и других изменяемых значений, в JS применяется ссылочная модель вычислений.
  Передача объектов в функцию
   Передача аргументов в функцию, как, впрочем, и возврат значений,  выполняется по правилам присваивания, а правила присваивания зависят от вычислительной модели. 
   Пример 4. Определим функцию, которая получает прямоугольник и изменяет его цвет.

function repaint(r, c) 
{
   r.color = c;
}

var rect = {width:100, height:200, color:"red"};
repaint(rect, "blue");
alert(rect.color);     // blue
   Перед выполнением тела функции аргумент rect присваивается параметру r. Согласно ссылочной модели имя r становится синонимом rect, и мы можем изменять свойства объекта rect, ссылаясь на него по имени r.
   Заметим, что то же самое происходит и со вторым параметром, адрес строки "blue" копируется в переменную c, но строки неизменяемы и мы не можем извлечь из этого ничего полезного.
   
   Вспомните нашу неудачу при попытке определить функцию для обмена двух чисел. Но может быть теперь мы в состоянии определить функцию, которая меняет местами значения двух объектов, скажем, двух прямоугольников?
   
function swap(r1, r2) 
{
   var t = r1;  r1 = r2;  r2 = t;
}

var rect1 = {width: 100, height: 200, color: "red"};
var rect2 = {width: 2, height: 3, color: "black"};
swap(rect1, rect2);
alert(rect1.width);    // 100
7.6. Объясните, почему функция swap не справляется с порученным ей делом?
  Заключение
1. Объект – это контейнер для свойств. Свойства могут быть любого типа, в том числе и объектного. 
2. Можно изменять как набор свойств объекта, так и значения самих свойств. В отличие от простых типов объект является изменяемым значением. 
3. Объекты подчиняются ссылочной модели вычислений, в которой каждое значение состоит из двух составляющих: собственно значения и ссылки на него.
4. При передаче объектов в функцию копируется не сами объекты, а их адреса, что позволяет изменять в теле функции отдельные свойства объекта.
8. Массивы
   Массивы – родственники объектов, точнее, их потомки. От прочих объектов массивы отличает то, что именами свойств у них служат целые числа: 0, 1, 2, и т.д. Предназначение массива – хранить пронумерованные последовательности любых данных – строк, чисел, объектов. В силу их специализации у массивов своя терминология: имена свойств называют индексами, а значения – элементами массива.
  Создание массивов
   Создать пустой массив можно при помощи конструктора – функции Array.
   
var arr = new Array();
   Это очень похоже на создание объектов конструктором Object().
   
var obj = new Object(); 
   У массивов тоже имеется альтернативный синтаксис. Вот как можно создать пустой массив.
   
var arr = [];  
Создать непустой массив можно так.
   
var trio = new Array(10, 20, 30);
var trio = [10, 20, 30];  // то же самое, но короче
К элементам массива обращаются по их индексам.

alert(trio[0]);    // 10
alert(trio[1]);    // 20
alert(trio[2]);    // 30
Элементы одного массива могут быть разнотипными.

arr[0] = 10;                       // число
arr[1] = "двадцать";               // строка
arr[2] = {with: 40, height: 50};   // объект
arr[3] = [1,2,3];                  // массив
   Несмотря на это, программисты отдают предпочтение массивам однотипных данных.
   У массива есть свойство length, которое хранит длину массива, т.е. количество элементов в нем. 
   Для перебора всех элементов массива хорошо подходит команда for.
   
var colors = ["красный", "синий", "зеленый"];

for (var i = 0; i < colors.length; i += 1)
   alert(colors[i]);
   Инкремент и декремент
   В связи с участившимся употреблением цикла for хочется упомянуть о двух арифметических операциях, без которых мы до сих пор успешно обходились. Желание вызвано тем, что в приращении цикла редко пишут i += 1, вместо этого встретишь i++ или ++i :
    
for (var i = 0; i < colors.length; ++i)
   Унарная операция ++ называется инкремент, унарная операция -- называется декремент. Операндом обеих операций может быть только переменная.
   Инкремент увеличивает значение операнда на 1, декремент, напротив, на 1 уменьшает. Обе операции имеют две формы, префиксную и постфиксную. Сначала рассмотрим две формы инкремента.
   Первая форма – префиксная, она называется преинкремент и обозначается ++i. Вторая форма – постфиксная, называется постнкремент и обозначается i++. Обе формы увеличивают свой аргумент на 1, но отличаются значением операции. 
   Что такое значение операции, понять легко: значение сложения 2 + 3 – это 5, значение вычитания 6 - 4 – это 2 и т.п., каждая операция  обязательно вырабатывает какое-то значение. Изменение же аргумента весьма необычно для операций, по крайней мере, никакие из уже известных нам операций этого не делали. 
   Различие между двумя операциями в вырабатываемом значении – постинкремент вырабатывает значение, равное значению аргумента до его увеличения на 1, преинкремент вырабатывает значение, равное значению аргумента после его увеличения на 1. 
   
var a = 1;
alert(a++); // 1;
var b = 1;
alert(++b); // 2;
   Но побочный эффект обеих операций одинаков, и в результате a и b станут равны двум. 
   Для пре- и постдекремента все абсолютно аналогично.
   
var a = 1;
alert(a--); // 1;
var b = 1;
alert(--b); // 0;
   Своим присутствием в JS эти экзотические операции обязаны языку Си (вы помните, язык JS имеет си-подобный синтаксис), а присутствием в языке Си они обязаны аналогичным машинным операциям (вы помните, язык Си близок к машинному). 
   Для программиста на Си разница между i += 1, ++i  и i++ весьма ощутима. Он никогда не напишет в цикле for приращение в виде i += 1 или  i++, только ++i, т.к. знает, что ++i работает быстрее.  
   Для программиста на JS это все едино, хотя ++i  короче, чем i += 1, а тому, кто раньше программировал на Си, и привычнее. 
   
8.1. Определите функцию, которая получает массив чисел и возвращает сумму его элементов.
8.2. Определите функцию, которая получает массив чисел и возвращает значение наибольшего из его элементов. 
8.3. Определите функцию, которая получает массив чисел и возвращает индекс наибольшего из его элементов. Если таких индексов несколько, пусть это будет наименьший из них.
8.4. Определите функцию join, которая получает массив и строку-разделитель и возвращает строку, в которую соединены все элементы массива с разделителями между соседними элементами. 
Например, join (["aa","bb","cc"],"--") -> "aa--bb--cc".

   Массивы, будучи объектами, подчиняются ссылочной модели вычислений. 

var colors = ["красный", "зеленый", "синий"];
var palette = colors;  

palette[1] = "желтый";
alert(colors[1]);       // желтый
   Если мы делаем массив аргументом функции, в функцию передается ссылка, и в теле функции можно изменить содержимое массива-аргумента. Например, функция swap получает массив и меняет местами его первый и последний элементы.
   
function swap(m) {
    var t = m[0];
    m[0] = m[m.length - 1];
    m[m.length - 1] = t;
}

var colors = ["red", "green", "blue"];   
swap(colors);
alert(colors);  // blue,green,red// 

8.5. Определите функцию reverse, которая получает произвольный массив и перестраивает его элементы в обратном порядке, т.е. получив массив [1, 2, 3], она сделает его таким: [3, 2, 1]. Функция ничего не возвращает, а только изменяет свой аргумент.
  Добавление и удаление элементов
   Добавить элемент в массив можно так же, как добавляют новое свойство в объект.
   
colors[3] = "желтый";
colors[4] = "оранжевый";
Такой способ добавления не ограничивает нас в выборе индексов, например:

colors[-1] = "черный";
colors[10] = "белый";
alert(colors); 
// красный,синий,зеленый,желтый,оранжевый,,,,,,белый
   В результате мы получили массив с «дырками», что подтверждает строка, выведенная функцией alert. К тому же элементы с отрицательными индексами вообще не были замечены функцией alert.
   Элементы массива это значения его свойств, поэтому удалять их может функция delete, которая специализируется на удалении свойств объектов.
   
var colors = ["красный", "синий", "зеленый"];
delete colors[1];
alert(colors);    // красный,,зеленый
В результате удаления образовалась «дырка».
   Вывод таков – хотя JS и позволяет добавлять и удалять из массива элементы с любыми индексами, необходимо придерживаться правила: элементы массива нумеруются с нуля и располагаются плотно. Легче всего соблюсти это правило, если пользоваться для добавления и удаления элементов методами массива: push, pop, unshift и shift. 
   Методы push и pop добавляют и удаляют элементы с конца массива.  Метод push возвращает текущее количество элементов. Метод pop возвращает удаляемый элемент.
    
var nums = [100, 200, 300];

var n = nums.push(400);

alert(nums);   // 100, 200, 300, 400
alert(n);      // 4

nums.pop();
var x = nums.pop();

alert(nums);  // 100, 200
alert(x);     // 300

Методы unshift и shift делают то же самое, что push и pop, но с начала массива.

var nums = [100, 200, 300];

var n = nums.unshift(400);

alert(nums);   // 400, 100, 200, 300
alert(n);      // 4

nums.shift();
var x = nums.shift();

alert(nums);  // 200, 300
alert(x);     // 100

Метод unshift возвращает количество элементов, метод shift возвращает удаляемый элемент.
    Названия методов должны помочь нам запомнить их смысл. Добавление в конец (push) похоже на заталкивание чего-то в хранилище, удаление с конца (pop) напоминает звук, с которым что-то выскакивает из туго набитого хранилища. Удаление с начала (shift) вызывает сдвиг к началу всех оставшихся элементов, добавление в начало (unshift) вызывает сдвиг в обратном направлении.
    Заметим, что операции, совершаемые в начале массива, занимают больше времени, чем операции, совершаемые в конце массива, именно из-за сдвига. Ведь сдвиг состоит в присваивании каждого элемента своему соседу.
    
8.6. Определите функцию shift(массив), которая сделает то же, что метод массива shift. В определении функции метод shift не используйте.
8.7. Аналогичным образом определите функцию unshift(массив, значение).

   Есть еще один способ удаления элементов с конца – путем «обрезания» массива при помощи свойства length.
   
var nums = [100, 200, 300, 400];
nums.length = 2;
alert(nums);   // 100, 200
   Свойство length хранит количество элементов только для «правильных» массивов, у которых индексы начинаются с нуля, а элементы расположены плотно. Строго говоря, свойство length хранит увеличенный на единицу индекс последнего элемента, а не количество элементов массива.
  Другие методы
   Массив – рабочая лошадка программиста. Не удивительно, что у него множество методов, и некоторые из них мы представим ниже.
   
Метод join(разделитель) соединяет в одну строку все элементы массива, вставляя строку-разделитель между соседними элементами. Те элементы, что строками не являются, предварительно преобразуются в строки.
   
var arr = [100, 200, 300];
var str = arr.join(":");
alert(str);      // 100:200:300
Метод строка.split(разделитель) решает обратную задачу по отношению к методу join – разбивает строку на массив строк. Вы конечно заметили, что split – метод строки, а не массива.

var str = "Пришел, увидел, победил!";
var arr = str.split(",");
for (var i = 0; i < arr.length; i += 1)
   alert(arr[i]);
   Метод indexOf(элемент) возвращает индекс элемента в массиве. Если таких элементов в массиве несколько, возвращается наименьший из их индексов.

var nums = [2,4,3,5,6,3,4];
alert(nums.indexOf(3));       // 2
При отсутствии элемента в массиве метод indexOf возвращает -1.

8.8. Кроме метода indexOf, у массива есть метод lastIndexOf, который возвращает индекс последнего вхождения элемента в массив. Определите функцию, lastIndexOf(массив, элемент) своими силами.

   Метод slice(начальныйИндекс, конечныйИндекс) возвращает новый массив, который является «срезом» исходного. Срез – это часть массива от начального индекса до конечного индекса, причем конечный индекс в срез не включается.

var nums = [00, 10, 20, 30, 40, 50];
alert(nums.slice(2, 5));    // 20, 30, 40
   Метод splice(индекс, количество, эл1, эл2, …) способен за один вызов и удалить, и добавить элементы в массив. Все параметры, кроме первого, не обязательны. Начиная с индекса, метод удаляет указанное количество элементов и вставляет в массив элементы эл1, эл2, … Метод возвращает массив, составленный из удаленных элементов. От применения метода splice «дырок» в массиве не остается.

var nums = [00, 10, 20, 30, 40, 50];
var del = nums.splice(1, 3, "aaa", "bbb"); 

alert(nums);    // 0, aaa, bbb, 40, 50
alert(del);     // 10, 20, 30
При помощи метода splice можно только удалять или только вставлять элементы.

var nums = [00, 10, 20, 30, 40];

// удалить 3-й элемент
nums.splice(3, 1);  
alert(nums);    // 00, 10, 20, 40

// вставить "one" и "two" с 1-й позиции
nums.splice(1, 0, "one", "two");
alert(nums);    // 00, one, two, 10, 20, 40
   У методов slice и splice есть еще одна примечательная особенность – отрицательные аргументы. Попробуйте догадаться, что делает вызов slice(1, -1)?
   
var nums = [00, 10, 20, 30, 40];
alert (nums.slice(1, -1));  // 10, 20, 30
   Отрицательность индекса означает, что счет элементов ведется с конца, т.е. -i – это length - i. 
  Заключение
1. Массивы – вид объектов, и на них распространяется ссылочная модель вычислений. Свойства массивов не именуются, а нумеруются целыми числами, начиная с 0. Изначально каждый массив имеет свойство length.
2. Если обращаться с массивом, как с обычным объектом, т.е добавлять и удалять произвольные свойства, то результат вызова функций и методов массива будет трудно предсказать. При обращении с массивом следует соблюдать правило: «Элементы массива нумеруются с нуля и располагаются плотно». Это правило соблюдается само собой, если оперировать с массивом посредством его методов: push, pop, unshift, shift и splice.
9. Пользовательский интерфейс
   Нашим программам не хватает того, что называют пользовательским интерфейсом. Мы можем легко написать функцию, которая найдет наибольший общий делитель или просуммирует числовой массив, но как сделать из этого полноценное приложение с вводом исходных данных, кнопкой «Вычислить» и выводом результата? Такую программу не стыдно было бы показать родным и знакомым.
   Язык JS не располагает средствами для общения с пользователем, но они есть в веб-браузере. Пока мы эксплуатировали только встроенный в браузер интерпретатор JS, но основная специальность браузера – отображать HTML-документы, и мы этим воспользуемся.
  О языке HTML
   Язык HTML (Hypertext Markup Language) появился на заре Интернета, и его роль в современном программировании очень важна. Как следует из названия, HTML – это язык разметки текста. На нем нельзя написать программу, как на алгоритмическом языке, но с его помощью можно превратить простой текст в то, что мы обычно видим в окне браузера – живую интерактивную страницу с текстом, изображениями, видео, звуком и гиперссылками.
   Текст размечается при помощи тэгов. Вот пример обычного, неразмеченного текста. 
   
   О языке HTML
Как следует из названия, HTML – это язык разметки текста. На нем нельзя написать программу...
   Если мы сохраним его в файле и откроем файл в браузере, то увидим пару невзрачных и невыразительных строк.
   
   Замечание. В современных браузерах не будет проблем с отображением русского текста, если сохранять документы в кодировке UTF-8.
   
   Теперь разметим текст с помощью тэгов языка HTML и снова откроем в браузере. 
   
<h1>О языке HTML</h1>
<p> 
  Как следует из названия <em>HTML</em>, – это язык разметки текста. На нем нельзя написать программу...
</p>
   Разметка сообщает браузеру, каким образом показывать те или иные фрагменты текста. Тэги <h1>…</h1> говорят о том, что их содержимое – заголовок первого уровня. Тэги <p>…</p> заключают в себе параграф. Тэги <em>…</em> подчеркивают важность их содержимого.
   При помощи тэгов можно не только форматировать текст, но и размещать в окне браузера различные управляющие элементы: поля для ввода текста, кнопки, переключатели, радиокнопки и т.п., и это именно то, что нам нужно.
  Структура HTML документа
   Большинство тегов HTML парные. Пару составляют открывающий и закрывающий теги, что весьма похоже на пару скобок: открывающую и закрывающую. Пары тэгов могут быть вложены друг в друга, как бывают вложены пары скобок. 
   Все правильно построенные HTML-документы имеют следующую структуру.
   
<!DOCTYPE HTML>
<html>
   <head>
     <!-- здесь информация для браузера -->    
   </head>
   <body>
     <!-- здесь то, что видит пользователь -->    
   </body>
</html>
   Первая строка служебная, она уточняет для браузера правила интерпретации следующего за ней документа.
   Тэг <html>…</html> корневой, это «скобки», которые обязаны окружать документ в целом. Документ состоит из двух разделов: заголовка, он окружен тэгами <head>…</head>, и тела, оно заключено в тэги <body>…</body>. В разделе заголовка расположена информация, которая поможет браузеру правильно отобразить документ. В теле находится то, что нужно отображать, и что, в конечном счете, увидит пользователь. 
   В приведенном выше примере документа никакой информации нет, вместо нее написаны комментарии. Да, в коде HTML тоже бывают комментарии, они обрамляются ограничителями <!-- и --> и могут занимать несколько строк.
  Тэги и атрибуты
   Английское слово tag переводится, как ярлык или бирка. Имя тэга несет в себе основную информацию разметки, дополнительная же информация передается в атрибутах. Общий вид парного тэга таков.
   
<тэг атрибуты> содержимое </тэг>
   Общий вид непарного тэга таков.
   
<тэг атрибуты />
   Тэги HTML можно разделить на группы. Сейчас нам наиболее интересна та группа, что позволяет пользователю вносить данные в программу. Основной тег этой группы называется input и он непарный, т.е. это не скобки, заключающие в себе часть документа, а целостное описание управляющего элемента. 
   Какой именно управляющий элемент задается тэгом input, определяет атрибут type: 
   type="text" – поле для ввода текста;
   type="button" – кнопка, которую можно нажать, кликнув мышью;
   type="checkbox" – переключатель;
   и т.д., всего более двадцати разных элементов, но все они едва ли нам понадобятся.
   Атрибут value позволяет задать значение управляющего элемента. Для поля ввода value – это текст в поле ввода, для кнопки value – это надпись на кнопке, для переключателя значение атрибута value невидимо для конечного пользователя.
   Еще один важный для нас атрибут называется id. Его значением является строка – идентификатор управляющего элемента. Благодаря id, можно получить ссылку на элемент в коде, написанном на JS. Кстати, атрибут id может быть у любого тэга, а не только у тэга input.
   
   Пример 1. Напишем программу для поиска НОД двух чисел. Для общения с пользователем программы нам понадобится:
1) два поля ввода, по одному для каждого из чисел;
2) кнопка с надписью «Найти НОД»;
3) элемент страницы, способный показать пользователю ответ. Из известных нам элементов на эту роль подойдет параграф.
   
   Все вместе это составит следующую HTML-страницу, которую мы сохраним в файле gcd.html.
    
    
<!DOCTYPE HTML>
<html>
   <head>
   </head>
   <body>
      <h1>Поиск НОД</h1>
      <p> Введите первое число 
          <input type="text" id="x" /> </p>
      <p> Введите второе число 
          <input type="text" id="y" /> </p>
      <input type="button" id="btn" value="Найти НОД" />
      <p id="mes"></p>
   </body>
</html>
   Итак, мы знаем, как создавать управляющие элементы для ввода данных, теперь посмотрим, как обратиться к ним из программы на JS.
  Модель документа
   Когда веб-браузер загружает HTML-документ, он создает в памяти иерархическую систему объектов в форме дерева. Тэги документа вместе с их содержимым становятся объектами и размещаются в узлах дерева. Вложенные тэги становятся дочерними узлами, атрибуты тэгов делаются свойствами объектов-элементов. 
   В литературе такие объекты называют HTML-элементами, так же будем поступать и мы. Программный интерфейс для работы с документом  называется DOM (Document Object Model). Он стандартизован и поддерживается всеми браузерами. 
   HTML-документ в целом представлен в DOM глобальным объектом document.  Метод объекта document.getElementById находит в дереве  элемент по его id и возвращает ссылку на него. Свое знакомство с DOM мы ограничим одним этим методом, его достаточно, чтобы получать ссылки на элементы из программы на JS (при условии, что у элемента есть атрибут id).
   Дополним пример 1 тэгом script, который содержит исполняемый код на JS. 
   
<!DOCTYPE HTML>
<html>
    <head>
    </head>
    <body>
        <h1>Поиск НОД</h1>
        <p> Введите первое число 
            <input type="text" id="x" /> </p>
        <p> Введите второе число 
            <input type="text" id="y" /> </p>
        <input type="button" id="btn" value="Calc" />
        <p id="mes"></p>
        <script>
            var elementX = document.getElementById("x");
            var elementY = document.getElementById("y");
            elementX.value = "12";   
            elementY.value = "8";           
        </script>
    </body>
</html>
   Этот код не вычисляет НОД, он лишь демонстрирует, как получить доступ к элементам страницы и как управлять элементами через их свойства.
   Порядок выполнения кода, заключенного в тэги <script>, следующий. Браузер просматривает документ сверху вниз и строит дерево элементов. Когда браузер встречает элемент script, он исполняет вложенный в него код, после чего продолжает просмотр документа и построение дерева. 
   Именно поэтому мы расположили тэг script в конце документа. Если перенести его в начало, метод document.getElementById не найдет нужные элементы – их еще не будет в дереве.
   
   Замечание. Программы, которые мы предлагали браузеру ранее, он воспринимал, как незаконченные html-документы, в которых "забыли" проставить тип документа и написать тэги html, head и body. Браузеры снисходительны, они прощают людям ошибки и пытаются отобразить документ с ошибками, исправляя их по своему разумению.
  События
   Пока пользователь просматривает документ в браузере, с документом и его элементами происходят разнообразные события: курсор мыши навели на какой-то элемент (событие mouseover), по элементу щелкнули мышью (событие click), курсор мыши покинул элемент (событие mouseleave), пользователь нажал клавишу на клавиатуре (событие keydown), отпустил клавишу (событие keyup) и много чего еще. 
   С каждым видом события программист может связать функцию, которая будет автоматически вызываться при наступлении события. Для такой связи у элементов есть особые функциональные свойства, которые называются так же, как события, только с приставкой "on": onmouseover, onclick, onmouseleave, onkeydown и т.п. 
   Например, если мы хотим, чтобы в ответ на событие click кнопки вызывалась некоторая функция f, необходимо: во-первых, получить ссылку на кнопку, во-вторых, присвоить свойству кнопки onclick функцию f. Разумеется, функция с именем f должна существовать.
   
   Пример 2. Изменим содержимое тэга script предыдущего примера и покажем его отдельно (остальное содержимое страницы осталось прежним).
   
<script>
   function f() 
   { 
      var el = document.getElementById("mes");
      mes.innerHTML = "Вызвана функция f";
   } 

   var button = document.getElementById("btn");
   button.onclick = f;       
</script>
   Функция f находит в документе элемент с идентификатором "mes" (это параграф) и делает его содержимым слова: "Вызвана функция f". Содержимое любого элемента доступно в коде через свойство innerHTML.
   Основная программа находит в документе элемент с идентификатором "btn" (это кнопка) и присваивает ее свойству onclick функцию f.
   Не удивлюсь, если вы потрясены, узнав, что функции можно присваивать, как числа, строки или объекты. Но это именно так! Отсутствие кардинальных различий между функциями и данными – одна из отличительных особенностей JS. 
   Теперь, когда мы научились связывать функции с событиями, можно завершить программу нахождения НОД. Все, что осталось сделать, это переписать функцию f. Она должна: 1) получить строки из полей ввода; 2) преобразовать строки в числа; 3) найти НОД этих чисел; 4) показать результат на странице. 
   Вот окончательное содержимое тэга script для программы поиска НОД.
   
var button = document.getElementById("btn");
button.onclick = f;	

function f() { 
    var x = Number(document.getElementById("x").value);
    var y = Number(document.getElementById("y").value);
    var el = document.getElementById("gcd");
    mes.innerHTML = gcd(x, y);
}

function gcd(x, y) {
    if (x < y) {
        var t = x; x = y; y = t;
    }
    while (y > 0) {
        t = y;
        y = x % y;   
        x = t;
    }
    return x;
}

Отделение JS от HTML
   В настоящий момент у нас в одном файле находятся два разных текста, к тому же написанные на разных языках. Один из них – описание пользовательского интерфейса на HTML, другой – программа, написанная на JS. Разные вещи лучше и хранить порознь, каждую в своем файле.
   Перенесем содержимое тэга <script> в отдельный файл, gcd.js, и поместим его в тот же каталог, где находится файл gcd.html. Прежний тэг <script> заменим таким:
    
<script src="gcd.js"></script>
   В языке HTML у тэга <script> есть два варианта употребления. В первом варианте код JS является содержимым  тэга. Во втором варианте код JS располагается в отдельном файле (как правило, с расширением js), и атрибут src тэга <script> содержит URL этого файла. Сочетать обе возможности в одном тэге не разрешается.
    
   Замечание. URL – это единый указатель ресурсов в глобальной сети или на локальном диске. 
   
   Если файл находится на локальном диске, то URL это путь к файлу, относительный или абсолютный. Относительный путь отсчитывается от каталога, в котором находится основной документ. Абсолютный путь отсчитывается от начала файловой системы и записывается в независимой от операционной системы форме, например, URL «file:///d:/gcd.js» означает, что файл gcd.js находится в корневом каталоге диска d: . 
Функциональные выражения
   Обратите внимание на ту часть кода, где определяется и присваивается функция f.
   
button.onclick = f;

function f() { 
    var x = Number(document.getElementById("x").value);
    var y = Number(document.getElementById("y").value);
    var el = document.getElementById("gcd");
    mes.innerHTML = gcd(x, y);
}
   Неспроста у функции f такое короткое и невыразительное имя, оно потребовалось нам лишь для того, чтобы выполнить присваивание. Оказывается и этого не нужно, поскольку JS позволяет определять безымянные функции. 
   
button.onclick = function () { 
    var x = Number(document.getElementById("x").value);
    var y = Number(document.getElementById("y").value);
    var el = document.getElementById("gcd");
    mes.innerHTML = gcd(x, y);
}
   Выражение в правой части присваивания называется функциональным выражением. Его значением является не число, не строка, а функция. 
   Приведем еще один пример функционального выражения.
   
var sum = function(a, b) { 
    return a + b; 
};
   В результате присваивания безымянная функция получает имя sum. Фактически это очень похоже на обычное определение функции.
   
function sum(a, b) { 
    return a + b; 
}
   Но различие все же есть. Оно в том, что в первом случае имя sum связывается с функцией во время выполнения программы, а во втором случае – во время предварительного просмотра. Иногда это различие существенно. 
   Например, это не работает.
   
alert(sum(1, 2));

var sum = function (a, b) {
    return a + b;
};
   А это работает.
   
alert(sum(1, 2));

function sum (a, b) {
    return a + b;
};
9.1. Что можно сделать, чтобы первый вариант тоже стал работать?
   
   Продолжая тему равноправия функций и данных в JS, заметим, что функции можно не только присваивать, но и передавать в другие функции, возвращать в качестве результата, писать функциональные выражения, выводить в окно командой alert(f) и даже добавлять им свойства, sum.prop = "foo". Секрет в том, что JS считает функцию разновидностью объекта (как строку или массив). 
   
9.2. Напишите программу для перевода температуры из шкалы Цельсия в шкалу Фаренгейта. Разработайте для нее пользовательский интерфейс, аналогичный интерфейсу программы определения НОД.
9.3. В программе для перевода температуры постарайтесь обойтись двумя полями ввода, устранив кнопку. Обработайте событие потери фокуса полем ввода.
  Заключение
1. HTML – не язык команд, а язык разметки. С его помощью можно придать пользовательский интерфейс программы, написанной на JS.
2. Браузер сохраняет HTML-документ в памяти в виде дерева объектов. Программный интерфейс для работы с этим деревом называется DOM – объектная модель документа. Из всего DOM нам понадобился пока только объект document и его метод getElementById.
3. Действия пользователя вызывают разнообразные события, которые происходят с документом и его элементами. Программист может определить функции, которые будут автоматически вызваться в ответ на события. 
4. JS и HTML разные языки, поэтому лучше отделить код на JS от кода разметки и сохранить их в разных файлах. Ссылка из файла разметки на код программы устанавливается при помощи тэга script с атрибутом src.
5. JS не делает различия между функциями и данными, и это сильная сторона языка, т.к. программы становятся короче и понятнее.
10. Системы счисления
   Хотя числа в программах записывают в десятичной системе счисления, нам нужно научиться работать с числами, записанными в любой позиционной системе счисления. Особый интерес представляют двоичная и 16-ичная системы, потому что в двоичном виде  числа хранятся в памяти компьютера, а 16-ичная система – это уплотненная двоичная.
  От записи к числу
   Определить величину числа по его записи позволяет формула (10.1).
   
   (an an-1 … a2 a1 a0)b = a0 * b0 + a1 * b1 + a2 * b2 +…+ an-1 * bn-1 + an * bn    (10.1)
   
   В этой формуле (an an-1 … a2 a1 a0) b  означает запись числа, в которой a0 – цифра младшего разряда, an – цифра самого старшего разряда. 
   Число b означает основание системы счисления. Для десятичной системы b = 10, для двоичной b = 2, для троичной b = 3 и т.д. Мы немного знакомы с десятичной системой, поэтому проверим формулу для нее.
   
   (2015)10 = 5 * 100 + 1 * 101 + 0 * 102 + 2 * 103  = 5 + 10 + 0 + 2000 = 2015
   
   (1011)10 = 1 * 100 + 1 * 101 + 0 * 102 + 1 * 103  = 1 + 10 + 0 + 1000 = 1011
   
   Теперь для двоичной.
   
   (1011)2 = 1 * 20 + 1 * 21 + 0 * 22 + 1 * 23  = 1 + 2 + 0 + 8 = 11
   
   Степени основания, b0, b1, b2, … называют весами разрядов. Для десятичной системы веса: 1, 10, 100, 1000,…, для двоичной: 1, 2, 4, 8, 16, …
   Основание это не только число, определяющее веса разрядов. Это еще и количество цифр, которые разрешено использовать в записи числа. 
   В десятичной системе – десять цифр, в двоичной – две: 0 и 1, в троичной – три: 0, 1, 2, в шестнадцатеричной – шестнадцать: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C. D, E, F. Древние вавилоняне пользовались 60-ичной системой, и я им не завидую.
   Определим функцию, которая по строке, содержащей запись двоичного числа, сможет вычислить его значение. Раз система двоичная, строка должна состоять только из нулей и единиц. 
   
function binStrToNumber(str) 
{
   var sum = 0;
   for (var k = 0; k < str.length; k += 1)
   {
       var pos = str.length - k - 1;
       sum += Math.pow(2, k) * str[pos];  
   }
   return sum; 
}
   Название функции должно звучать как «двоичную строку – в число». Вычисление ведется по формуле (10.1) при условии, что b = 2. Результат вычисления – это сумма, которая накапливается в переменной sum.
   Счетчик k означает номер разряда числа. К сожалению, номер разряда и позиция цифры в строке не совпадают. В строке «1011» младший разряд стоит последним, а старший первым. Чтобы номер разряда и номер позиции совпадали, число пришлось бы писать справа налево. Но есть простая закономерность, которая по номеру разряда позволяет определить позицию символа.
   
  var pos = str.length - k - 1;
   Следующая команда вычисляет очередное слагаемое и прибавляет его к сумме.
   
  sum += Math.pow(2, k) * str[pos];  
   Здесь нам помог интерпретатор, который неявно преобразовал односимвольную строку str[pos] в число, т.е. строку "0" он перевел в число 0, а строку "1" в число 1. 
   В формуле Math.pow(2, k) вы, конечно, узнали возведение в степень –2k. Мы можем обойтись без затратного возведения в степень, но понадобится еще одна переменная, weight – вес разряда.
   
function binStrToNumber(str) 
{
   var sum = 0, weight = 1;
   for (var k = 0; k < str.length; k += 1)
   {
       var pos = str.length - k - 1;
       sum += weight * str[pos];  
       weight *= 2;
   }
   return sum; 
}
10.1. Обобщите функцию binStrToNumber, добавив ей второй параметр, b – основание системы счисления (2 <= b <= 10). Если функция вызывается только с одним аргументом,  считайте, что b = 10. Назовите обобщенную функцию stringToNumber.
10.2. Расширьте диапазон значений второго параметра функции stringToNumber до 16. 
10.3. Придайте функции stringToNumber пользовательский интерфейс, состоящий из поля для ввода двоичной записи числа, копки "ToNumber" и параграфа с результатом преобразования.
  От числа к записи
   Займемся обратным переходом – от числа к его записи в позиционной системе счисления с заданным основанием. Запись числа – это последовательность его цифр, начиная с младшей.
   Начнем с двоичной системы. Пусть имеется некоторое число X. Как узнать его младшую цифру в двоичной системе счисления? Очень просто – взять остаток от деления на 2. В самом деле, посмотрим на формулу (10.1) при b = 2.
   
   X = (an an-1 … a2 a1 a0)2 = a0 + a1 * 2 + a2 * 22 +…+ an-1 * 2n-1 + an * 2n 
   
   Если разделить X на 2, все слагаемые, кроме первого, разделятся на 2 без остатка. Число a0 будет остатком от деления X на 2, т.е. 
   	a0 = X % 2.
   Первую цифру узнали.
   Следующая цифра – это a1. Если бы мы знали число X' = (an an-1 … a2 a1)2, которое на одну цифру короче, чем X, то a1 была бы его младшей цифрой, а уж младшую-то цифру мы находить умеем.
   Наша мечта не так уж несбыточна. Вычтем из X a0 и разделим разность на 2. 
   (X - a0) / 2 = (a1 * 2 + a2 * 22 +…+ an-1 * 2n-1 + an * 2n) / 2 =
    = a1  + a2 * 2 +…+ an-1 * 2n-2 + an * 2n-1 
   По формуле (10.1) эта сумма должна быть записана в виде (n-1)-разрядного числа (an an-1 … a2 a1)2, того самого X', о котором мы мечтали, т.е.
   X' = (X - a0) / 2
   
   Остальные цифры можно найти таким же способом:
1) получаем младшую цифру числа: ai = X % 2;
2) «укорачиваем» число на одну цифру X = (X – ai) / 2;
   
   Проверим алгоритм на конкретном числе, например, X = 5.

a0 = 5 % 2 = 1;
X = (5 – 1) / 2 = 2;
a1 = 2 % 2 = 0;
X = (2 – 0) / 2 = 1;
a2 = 1 % 2 = 1;
X = (1 – 1) / 2 = 0;       // конец вычислений
a3 = a4 = a1000 = 0 % 2 = 0; // пошли нули
X = (0 – 0) / 2 = 0;
   Получилось – 0…0101.
   Вычисления стоит продолжать, пока текущее число X не станет равным нулю. После этого все остальные цифры будут только нулями. Мы иногда видим такие нули в записи чисел, например, "агент 007", но знаем, что числа 007 и 7 обозначают одно и то же количество (но, видимо, разных агентов).
   Наши рассуждения приобретут общий характер, если заменить в них основание системы 2 на b. 
   a0 = X % b;
   Действительно, младшая цифра в записи числа является остатком от деления на основание, поскольку a0 < b, а все прочие слагаемые формулы (10.1) делятся на b без остатка. 
   X' = (X - a0) / b
   "Отрезать" от числа младший разряд можно, вычтя из него число a0 и разделив разность на b. Согласно формуле (10.1) полученное выражение,  
   a1 * 20 + a2 * 21 +…+ an-1 * 2n-2 + an * 2n-1
   записывается как (an an-1 … a2 a1)b .
   
   Теперь мы готовы запрограммировать переход от числа к его записи в виде функции numberToString(число, основание). Основание можно задавать в пределах от 2 до 10.
   
function numberToString(x, b)
{
    var res = "";
    while (x > 0) 
    {
        var a = x % b;
        res = a + res;
        x = (x - a) / b;
    }
    return res;
}
   Результатом вычислений является строка. Изначально она пуста, поэтому: var res = "";
   При каждом повторении цикла в переменной a появляется очередная цифра числа: var a = x % b;  Цифра в переменной a имеет числовой тип.
   Эта цифра присоединяется к строке-результату слева: res = a + res; (как вы помните, если складываются число и строка, то число приводится к строке и уже две строки соединяются).
   У нашей функции есть недостаток, она плохо справляется с числом 0. И без проверки видно, что в этом случае цикл не выполнится ни разу и функция вернет пустую строку, а не строку "0", как хотелось бы.
   
10.4. Устраните указанный недостаток и сделайте так, чтобы в ответ на нулевое значение первого параметра функция numberToString возвращала строку "0".
10.5. Расширьте диапазон возможных значений второго параметра функции numberToString до 16. Совет: воспользуйтесь строкой "0123456789ABCDEF".
10.6. Определите функцию convert, которая переводит запись числа в одной позиционной системе счисления в запись числа в другой системе. У функции должно быть три параметра: запись числа, исходное основание, целевое основание.
10.7. Придайте пользовательский интерфейс функции convert.
   Родственные системы счисления
   Системы счисления, у которых основания b1 и b2 связаны соотношением 
   b1 = b2 k, 
   где k – целое число, хочется назвать родственными. Перевод чисел из одной системы в другую требует минимальных усилий. 
   Например, переведем двоичное число 1101010112 в восьмеричную систему. 
   8 = 23, поэтому разбиваем исходное число на тройки разрядов:
   110|101|011
   Каждую тройку заменяем одной восьмеричной цифрой, и ответ готов:  6538.
   Обратный перевод столь же прост. Переводим отдельно каждую восьмеричную цифру в двоичную форму, дополняя нулями до трех разрядов, если нужно.
   53168 => 101|011|001|1102
        
   Двоичная и шестнадцатеричная системы родственны, 16 = 24. Теперь понятно, почему запись чисел в 16-ичной системе в 4 раза короче, чем в двоичной.
   
10.8. Запись чисел в десятичной системе тоже короче, чем в двоичной. Можно ли сказать, во сколько примерно раз?

   Троичная симметричная система
   В одной из первых ЭВМ, "Сетунь", числа хранились в троичной симметричной системе счисления. Веса разрядов в этой системе были степенями тройки, а цифры: 0,1 и -1. Для удобства записи цифру -1 будем заменять буквой i. Вот несколько первых чисел, записанных в троичной симметричной системе счисления.
   
 0 –   0    
 1 –   1   
 2 –  1i   
 3 –  10   
 4 –  11   
 5 – 1ii   
 6 – 1i0   
 7 – 1i1   
 8 – 10i   
 9 – 100  
10 – 101  
   
10.9. Определите функцию, которая получает натуральное число и возвращает строку – запись числа в троичной симметричной системе счисления. За основу возьмите функцию перевода числа в обычную троичную систему, но каждый раз, когда очередной цифрой будет двойка, заменяйте ее на i и вносите поправку в текущее значение числа x. 
  Заключение
1. Следует отличать число как некоторое количество и изображение этого количества при помощи символов. Число – понятие абсолютное, изображение же числа зависит от принятого способа записи. Мы познакомились с позиционными системами, в которых связь между числом и изображающей его строкой задается формулой (10.1).
2. Основание позиционной системы определяет веса разрядов и допустимое количество цифр. Если бы цифр было меньше, не все числа удалось бы записать, если бы цифр было больше, то одно число можно было бы записать разными способами.
11. Оценка производительности
   У каждой задачи на программирование есть множество решений, и алгоритмы этих решений могут быть хорошими или плохими. Программист должен иметь  некую меру, чтобы оценивать и сравнивать различные алгоритмы. Очень важным качеством алгоритма является время, затраченное им на решение задачи. Но всякий алгоритм массовый, т.е. решает множество однотипных задач. Например, алгоритм поиска максимального числа в массиве применим к любому числовому массиву. С короткими массивами он справится быстро, на длинные же потратит больше времени. Так как же быть? 
   Выход в том, чтобы измерять быстродействие алгоритма не в секундах, не в тактах процессора, не в количестве выполненных им простых операций, а в виде зависимости. Да, в виде зависимости числа выполняемых операций от количества входных данных. Такая зависимость задается функцией f(n), где n – количество входных данных. Вид функции f(n) мы  будем определять путем логических рассуждений.
   Вопрос о том, что именно считать количеством входных данных для той или иной задачи, обычно не вызывает трудностей. Поскольку мы намерены заняться массивами, за n естественно принять размер массива. В других задачах, таких как поиск НОД или определение простоты числа, смысл n будет иным. 
   Рассмотрим несколько алгоритмов и попытаемся оценить их временную сложность (так называют то качество алгоритмов, что нас интересует).
  Задача поиска
   Имеется массив однородных данных, это могут быть библиотечные карточки, личные дела тайных агентов, статьи словаря, словом, все что угодно. Их роднит то, что каждый элемент данных имеет уникальный идентификатор (ключ). Задача поиска состоит в том, чтобы по заданному ключу определить индекс элемента массива.
   Поскольку в задаче поиска природа данных никакого значения не имеет, далее мы будем рассматривать поиск в массиве строк. Строка в таком случае является ключом, а все прочие данные составляют пустое множество. В такой, немного абстрактной, постановке задача поиска сводится к тому, чтобы по заданной строке найти ее индекс в массиве. В решении необходимо предусмотреть ситуацию, когда искомого ключа в массиве нет. 
   Ключи в массиве могут быть расположены хаотически, а могут быть выстроены в каком-нибудь порядке, например, по возрастанию.
  Поиск в неупорядоченном массиве
   Последовательный поиск
   Алгоритм последовательного поиска состоит в том, чтобы последовательно просматривать элемент за элементом, пока не найдем заданный ключ или не достигнем конца массива. В последнем случае результатом поиска будет -1, и это означает, что ключа в массиве нет. 
   Реализацией изложенного алгоритма является функция serialSearch.
   
function serialSearch(arr, key)
{
   var n = arr.length;
   for (var i = 0; i < n; i += 1)
      if (arr[i] == key)
         return i;
   return -1;
}
   Может оказаться, что искомый ключ находится в самом начале массива и поиск выполнится мгновенно. Ясно, что оценка лучшего случая не может послужить для сравнения алгоритмов и поэтому нас не интересует.
   Иное дело худший случай. Для данного алгоритма он состоит в том, что искомого ключа нет в массиве. Чтобы убедиться в этом, придется просмотреть весь массив. Для этого функции serialSearch придется выполнить 3*n операций, где n – количество элементов массива. Три операции это: сравнение (i < n), сложение (i += 1) и еще одно сравнение  (arr [i] == key). Конечно, есть и другие операции, но только эти три важны, т.к. выполняются в цикле, который повторяется много, а точнее, ровно n раз.
   Итак, можно утверждать, что зависимость числа операций от объема входных данных для алгоритма последовательного поиска выражается функцией
   	f(n) = 3n + С,
   где С – общее число операций, которые придется выполнить до начала цикла и после его окончания. Эта величина не зависит от n и не влияет на скорость роста функции, поэтому ею обычно пренебрегают. 
   Поиск с порогом
   Кажется, что последовательной поиск невозможно ускорить, но это только кажется.  Добавим искомый ключ в конец массива. Это позволит сократить число выполняемых в цикле операций до двух, т.к. исключается проверка выхода за границу массива.
   
function thresholdSearch(arr, key)
{
   arr.push(key);

   for (var i = 0; arr[i] !== key; i += 1)
      ;
   if (i === arr.length - 1)        
      return -1;
   return i;
}
   Если в цикле будет найден нарочито внесенный ключ, значит, ключа в массиве не было и нужно возвращать -1.
   Оценка поиска с порогом:  f(n) = 2*n + С.
   Поиск в упорядоченном массиве
   Предположим, что элементы массива упорядочены по возрастанию ключа. Конечно, не всякие значения можно упорядочить, но некоторые можно, и строки именно таковы.
   И к упорядоченному массиву можно применить последовательный поиск. Его даже можно усовершенствовать так, чтобы прекращать работу, как только очередной ключ превысит искомый, но есть идея получше, и это – алгоритм двоичного поиска
   Сформулируем алгоритм в предположении, что ключи в массиве упорядочены по возрастанию.
   
   1.	Делим область поиска пополам (первоначально область поиска занимает весь массив).
   2.	Сравниваем искомый ключ с ключом в середине области.
   3.	Если ключи совпадают, поиск успешно завершен, возвращаем индекс середины области.
   4.	Если искомый ключ меньше серединного, продолжаем поиск в левой половине области.
   5.	Если искомый ключ больше серединного, продолжаем поиск в правой половине области.
   6.	Пункты 1-5 повторяем, пока область поиска не станет пустой. Когда она опустеет, возвращаем -1 в знак того, что искомого ключа в массиве нет.
   Функция binarySearch является реализацией алгоритма двоичного поиска на JS.
   
function binarySearch(arr, key)
{
   var b = 0, e = arr.length;
   while (b < e) {
      var m = Math.floor((b + e) / 2); 
      if (arr[m] == key) 
         return m;   // нашли
      if (key < arr[m]) 
         e = m;      // ищем слева
      else 
         b = m + 1;  // ищем справа
   }
   return -1;        // не нашли
}
   Переменные b (от слова begin) и e (от слова end) хранят начало и конец области поиска. Область поиска это участок массива от arr[b] до arr[e], но сам arr[e] в нее не входит. 
   Условие b < e истинно, если область поиска содержит хотя бы один элемент.
   В переменной m (от слова middle) – середина области поиска. 
   	var m = Math.floor((b + e) / 2);
   Результат деления не всегда целое число, а индекс массива обязан быть целым, поэтому мы отбрасываем дробную часть при помощи функции Math.floor.
  Оценка двоичного поиска
   Оценим количество операций, которые должен выполнить алгоритм двоичного поиска в худшем случае. Оценку будем давать в виде зависимости числа операций от размера массива, как мы делали это раньше. Заметим, что «число операций» и «время выполнения» для нас равнозначны, и мы будем использовать оба выражения как синонимы.
   Алгоритм двоичного поиска тоже циклический, но на каждом витке цикла область поиска сокращается не на один элемент, а примерно вдвое. Время поиска, t(n), в массиве из n элементов складывается из времени выполнения одного витка цикла и времени, которое понадобится для поиска в одной из половин массива, t(n / 2). 
   Не станем мелочиться и считать операции поштучно, просто отметим, что на  одном витке их постоянное количество C, не зависящее от n.
   	t(n) = C + t(n / 2)
   По тем же соображениям время поиска в половине массива:  
   	t(n / 2) = C + t(n / 4), 
   поэтому:
           t(n) = C + t(n / 2) = C + C + t(n / 4),
   Продолжая деление пополам, получим:
   t(n) = C + t(n / 2) = 2* C + t(n / 22) = 3* C + t(n / 23) = …= k* C + t(n / 2k);
   Выражение t(n / 2k) – это время поиска на участке, который образовался в результате деления исходного массива пополам k раз. 
   С каждым витком цикла область поиска сокращается вдвое, пока рано или поздно не составит один элемент. Предположим, число k –  номер витка, на котором это случится, тогда 
   n / 2k = 1. 
   Отсюда легко понять, что k = log2 n.  Значит,
   
   	t(n) =  k * C + t(1) = С * log2(n) + C0, 
   
   где  C0 = t(1) – время поиска в одноэлементной области. Это время не зависит от n.
  Сравнение алгоритмов поиска
   Итак, временную сложность алгоритма двоичного поиска можно оценить как функцию
   tb(n) =  Сb * log2(n) + Cb0.

   Если таким же образом, не уточняя констант, оценить время последовательного поиска, получим оценку
   	ts(n) =  n * Cs + Cs0.
   Точно так же выглядит и оценка поиска с порогом.
   	tt(n) =  n * Ct + Ct0.
   С той высоты абстракции, на которою мы поднялись, и последовательный поиск, и поиск с порогом оцениваются одинаково, т.к. обе функции, ts(n) и tb(n), с ростом n растут с одинаковой скоростью.
   
   Что это значит, «функции f и g растут с одинаковой скоростью»? Это значит, что функция f(n) растет не быстрее, чем g(n), и в то же время функция g(n) растет не быстрее, чем f(n). 
   Но что значит, «функция f растет не быстрее, чем g»? Это значит, что начиная с некоторого n0,  для всех n > n0, f(n) будет всегда меньше, чем С*g(n) где С – некоторая константа.
   
   
   
   Рисунок 11.1 - Функция f растет не быстрее, чем функция g
   
   Вернемся к конкретике. Есть две функции f(n) = 2*n и g(n) = 3*n. 
   Функция g растет не быстрее, чем f. Действительно, начиная с n = 0, при С = 2  f(n) * С > g(n).
   Так же легко показать, что функция f растет не быстрее, чем g. Поэтому верно, что функции 2*n и 3*n растут с одинаковой скоростью.
   Получается, что функции n, 100000*n и 0.000001*n растут с одинаковой скоростью? Получается, что так, и это очень полезная абстракция, позволяющая различать действительно разные алгоритмы.
   
   Сравним теперь временную сложность последовательного и двоичного поиска, т.е. функции ts(n) и tb(n). 
   Нетрудно доказать, что ts(n) растет быстрее, чем tb(n). Т.е. какое бы гигантское число С мы не придумали, всегда найдется такое n0, после которого n  догонит и перегонит С * log2(n). Чтобы понять, что это означает на практике, рассмотрим конкретный пример.
   Пусть дан массив из 1000 элементов, в котором оба алгоритма, последовательный и двоичный, находят элемент за одну секунду. Это вполне возможно, так как витков цикла в двоичном поиске меньше, но сам виток содержит больше операций.
    Спрашивается, за сколько времени эти же алгоритмы найдут ключ в массивах из одного миллиона и одного миллиарда элементов?
   Ответ дает следующая таблица.
   
Алгоритм поиска
n = 1000
n = 1000000
n = 1000000000
Последовательный
1 сек
16 мин 40 сек
11.5 суток
Двоичный
1 сек
2 сек
3 сек
   
   В самом деле, время последовательного поиска прямо пропорционально числу элементов массива. Если мы увеличим массив в 1000 раз, то и время поиска в нем возрастет в 1000 раз.
   Двоичный же поиск за одну секунду смог сократить область поиска с 1000 до одного элемента, т.е. в 1000 раз. Поэтому, чтобы сократить область поиска в миллион раз ему понадобится всего две секунды, а в миллиард раз – три.
  «О» большое
   В книгах по программированию временную сложность последовательного поиска, да и вообще всех алгоритмов, время работы которых пропорционально объему входных данных, обозначают O(n). Почему?
   Как мы уже отметили, любая из линейных функций растет не быстрее всех других линейных функций. В математике множество функций, которые растут не быстрее, чем f обозначают O(f). Поэтому, 
   O(1000000n + 1010) = O(0.0001n) = O(n),
   т.к. обозначают одно и то же множество функций. Вполне естественно, что из всего множества линейных функций для обозначения временной сложности была выбрана самая простая, f(n) = n.
   Совершенно по тем же соображениям временную сложность двоичного поиска обозначают O(log n). Не стоит спрашивать, по какому основанию здесь логарифм, т.к. функция logan, растет не быстрее чем функция logbn, конечно, если a и b константы.
   Временную сложность алгоритма, время работы которого не зависит от объема входных данных, обозначают O(1). 
   Есть несколько простых функций, которые часто используются при оценке временной сложности. Перечислим их по возрастанию скорости роста.
   		log(n)  <  n? <  n <  n2 <  n3 <  2n  <  n!  
   
11.1. Докажите, что функция logan, растет не быстрее чем функция logbn.
11.2. Оцените временную сложность алгоритма поиска наименьшего числа в массиве.
11.3. Определите функцию, которая получает массив чисел, упорядоченных по возрастанию и еще одно число. Функция должна вставить число в массив так, чтобы порядок не нарушился. Оцените ее временную сложность.
11.4. Что следует считать объемом входных данных в алгоритме перевода числа в двоичную систему счисления? После ответа на этот вопрос оцените временную сложность алгоритма перевода.
  Заключение
1. В неупорядоченном массиве возможен лишь последовательный поиск, временная сложность которого – O(n).
2. Вариант поиска с порогом имеет такую же оценку, но работает в полтора раза быстрее.  Если два алгоритма решения одной задачи имеют одинаковую оценку временной сложности, это не значит, что они равноценны. Иногда увеличение быстродействия даже на 5% имеет значение.
3. В упорядоченном массиве возможен двоичный поиск, временная сложность которого – O(log n). Пока мы не знаем, во что обойдется упорядочение, но понимаем, что отсортировать массив нужно один раз, а поиск в нем после этого можно выполнять многократно.
4. Хотя поиск с порогом – образец остроумного решения, его практическое значение невелико, т.к. время любого поиска в маленьких массивах мало, а поиск в больших массивах должен быть двоичным.
12. Сортировка массивов
   Мы убедились, что упорядоченный массив – благодарная почва для поиска, недаром все хранилища данных каким-то образом упорядочены. В этом разделе мы рассмотрим алгоритмы, при помощи которых неупорядоченный массив данных можно сделать упорядоченным, т.е. отсортировать данные по ключу.
   Может возникнуть вопрос, зачем нам эти алгоритмы, если у массива есть метод sort, который все прекрасно сделает? Ответ прост – чтобы научиться программировать. Программирование требует не только знания языков, но и знания алгоритмов. Алгоритмы, придуманные другими, снабдят вас запасом идей для написания собственных программ и выработают вкус к хорошему коду.
  Задача сортировки
   У задачи сортировки тот же предмет, что у задачи поиска – массив однородных данных с ключами. Эти данные надо отсортировать, т.е. расположить в том же массиве, но в порядке возрастания или убывания ключей.  Как правило, задачу сортировки решают, не используя дополнительного массива, но бывают исключения.
   При рассмотрении алгоритмов поиска мы без потери общности ограничились массивом строк. В этом разделе будем сортировать массивы чисел, просто, чтобы код примеров был еще короче.
   Итак, дан массив чисел. Необходимо упорядочить числа по возрастанию. 
  Сортировка выбором
   Мысленно разделим весь массив на две части. Правая часть – не отсортированная, левая – уже упорядоченная. Вначале левая часть пуста, а правая охватывает весь массив. 
   Алгоритм сортировки выбором следующий.
1. Выбрать наименьшее число в правой (хаотической) части.
2. Поменять его местами с начальным элементом правой части.
В результате обмена граница между упорядоченной и хаотической частью сместится на один элемент вправо.
   Пункты 1 и 2 нужно повторить n-1 раз, где n – число элементов массива.
   Вот "кинограмма" процесса сортировки. Хаотическая часть массива взята в рамку. Наименьшее число в этой части показано жирным шрифтом.
   
   30  40  20  10  50  80  60  
   
   10  40  20  30  50  80  60  
   
   10  20  40  30  50  80  60  
   
   10  20  30  40  50  80  60  
   
   10  20  30  40  50  80  60  
   
   10  20  30  40  50  80  60  
   
   10  20  30  40  50  60  80  

   Рассмотрим реализацию сортировки выбором в виде функции selectSort. Функция получает массив и ничего не возвращает. В результате вызова функции массив делается упорядоченным.
   
function selectSort(arr)
{
   for (var b = 0; b < arr.length - 1; b += 1) 
   {
      // пункт 1)
      var idx = minIndex(arr, b);

      // пункт 2)
      var t = arr[b]; 
      arr[b] = arr[idx]; 
      arr[idx] = t;
   }  
}

function minIndex(a, i) 
{
   var iMin = i;
   for (; i < a.length; i += 1) 
      if (a[i] < a[iMin])
         iMin = i; 
   return iMin;
}

var arr = [30, 40, 20, 10, 50, 80, 60];
selectSort(arr);
   Цикл в теле функции обеспечивает многократное повторение двух пунктов алгоритма. Переменная, управляющая циклом, называется b – от слова bound – граница.
   Для поиска индекса наименьшего числа в неупорядоченной части массива определена вспомогательная функция minIndex. Функция получает массив и индекс, правее которого ведется поиск. 
   Вспомогательная функция снимает часть нагрузки с кода основной функции. Еще один повод для определения функции minIndex то, что поиск индекса минимального числа – это отдельная задача.
  Вложенные функции
   Здесь нужно сделать отступление от темы сортировки и поговорить о структуре кода. 
   Применение вспомогательной функции позволило выделить в первоначальной  задаче подзадачу и решить ее отдельно. В результате код решения основной задачи стал проще. Выражаясь академически, мы произвели декомпозицию задачи. Декомпозиция – основной метод борьбы со сложностью в программировании.
   Правда, теперь для выполнения сортировки требуется две функции, а не одна. Это немного обременительно, но дело можно поправить, если вложить определение вспомогательной функции в основную.
   
function selectSort(arr)
{
   for (var b = 0; b < arr.length - 1; b += 1) 
   {
      // пункт 1)
      var idx = minIndex(arr, b);

      // пункт 2)
      var t = arr[b]; 
      arr[b] = arr[idx]; 
      arr[idx] = t;
   } 

   function minIndex(a, i) 
   {
      var iMin = i;
      for (; i < a.length; i += 1) 
         if (a[i] < a[iMin])
            iMin = i; 
      return iMin;
   } 
}
   Имя вложенной функции не видно за пределами тела функции selectSort. Оно теперь стало локальным, наряду с именами параметров и локальных переменных
   Внутренняя функция также образует отдельную область видимости, поэтому мы без опаски используем в ее коде такие же имена, как во внешней, ибо из тела функции selectSort они не видны.
   В то же время из тела внутренней функции видны все переменные, объявленные во внешней, в том числе и ее параметры. Благодаря этому внутреннюю функцию можно определить и без параметров.
   
function selectSort(arr) {
    for (var b = 0; b < arr.length - 1; b += 1) {
        // пункт 1)
        var idx = minIndex(arr, b);
        // пункт 2)
        var t = arr[b];
        arr[b] = arr[idx];
        arr[idx] = t;
    }

    function minIndex() {
        var iMin = b;
        for (var i = b; i < a.length; i += 1)
            if (a[i] < a[iMin])
                iMin = i;
        return iMin;
    }
}

var a = [4, 2, 1];
selectSort(a);
alert(a);
   Сравните, пожалуйста, два варианта программы, и убедитесь, что параметры делают функцию нагляднее и безопаснее в отношении случайных ошибок.
   Закончим наш экскурс в JS и вернемся к алгоритмам сортировки. 
  Сложность сортировки выбором
   Оценим временную сложность сортировки выбором. Алгоритм состоит из цикла, на каждом витке которого выполняются поиск минимального числа и обмен двух значений.
   Время выполнения k-ого витка цикла составит
   tk = C1 + C2 * (n - k + 1), 
   где C1 и C2 – константы, n – длина сортируемого массива. 
   В самом деле, C2 * (n - k + 1) – это время поиска минимального числа в хаотической части. На первом витке, оно равно C2 * n, на втором – C2 * (n-1) и т.д. Налицо арифметическая прогрессия, сумма членов которой и составит общее время сортировки.
       tss(n) = t1 + t2 +… + tn-1+ tn. = n*С1 + C2 * n * (n + 1) / 2;
       И без вычислений можно догадаться, что старшая степень в этом выражении – n2. Следовательно, tss(n)  растет не быстрее, чем n2, и оценка алгоритма – O(n2).  
       Квадратичная сложность означает, что алгоритм будет хорошо справляться с массивами порядка тысячи элементов, но к массивам из миллиона элементов его применять не стоит.
12.1. Время идет, компьютеры совершенствуются. Выясните, где проходит граница применимости сортировки выбором для вашего компьютера. Границей условимся считать размер массива чисел, который сортируется за 1 минуту.
  Сортировка вставками
   Подобно сортировке выбором, разделим массив на две области: слева уже упорядоченная, справа – область хаоса. Вначале упорядоченная область состоит из одного элемента (область из одного элемента всегда упорядочена), а хаотическая – весь остальной массив.
   Алгоритм сортировки вставками таков.
1. Берем первое число из хаотической области. 
2. Просматриваем упорядоченную область справа налево, пока не найдем место для этого числа.
3. Вставляем число в отсортированную область на найденное место. 
   Повторяем эти три пункта  n – 1 раз. На каждом шаге алгоритма неупорядоченная область сокращается, а упорядоченная возрастает ровно на один элемент.
   Просмотрим "кинограмму". Неупорядоченная часть массива взята в рамку. Жирным шрифтом показан элемент, вставленный в упорядоченную часть.
   
   30 40 20 10 50 80 60  
   
   30 40 20 10 50 80 60  
   
   20 30 40 10 50 80 60  
   
   10 20 30 40 50 80 60  
   
   10 20 30 40 50 80 60  
   
   10 20 30 40 50 80 60  
   
   10 20 30 40 50 60 80  
   
12.2. Запрограммируйте сортировку вставками в виде функции insertSort. Совет: совместите поиск места вставки с раздвижкой элементов упорядоченной части массива. Используйте не вспомогательную функцию, а вложенные циклы.

   Оценим временную сложность сортировки вставками.
   Алгоритм содержит два цикла, один из которых вложен в другой. Внешний цикл выполняется n – 1 раз, именно столько элементов изначально содержит хаотическая область. Внутри внешнего цикла происходит поиск правильного места в отсортированной области и вставка. 
   Хотя, как известно, поиск в упорядоченном массиве требует O(log n) операций, вставка все равно потребует O(n) операций, т.к. надо раздвигать элементы массива. 
   В итоге приходим к той же оценке, что и для сортировки выбором – O(n2).   
  Простая обменная сортировка 
   Ее часто изучают в школьных курсах информатики, потому что у нее самый простой и наглядный алгоритм.
   
1. Проходим массив слева направо, сравнивая пары соседних чисел и меняя их местами, если пара нарушает желаемый порядок.
2. Повторяем первый пункт  n – 1 раз. Каждый раз длину прохода сокращаем на 1.
   
   Сокращение длины прохода объясняется тем, что за каждое прохождение массива, по меньшей мере, одно число попадает на свое законное место, т.е. туда, где оно должно стоять в полностью отсортированном массиве.
   Пример обменной сортировки.
   
   30 40 20 10 50 80 60  
   
   30 20 40 10 50 80 60  
   
   30 20 10 40 50 80 60  
   
   30 20 10 40 50 60 80  
   ----------------------- первый проход окончен
   30 20 10 40 50 60 80
     
   20 30 10 40 50 60 80  
   
   20 10 30 40 50 60 80  
   ----------------------- второй проход окончен
   20 10 30 40 50 60 80  
   
   10 20 30 40 50 60 80  
   ----------------------- третий проход окончен
   
   Сделано только три прохода, но массив уже полностью упорядочен, поэтому продолжать нет смысла. Признаком полной упорядоченности массива может быть то, что при очередном проходе не сделано ни одного обмена.
   
12.3. Запрограммируйте обменную сортировку в виде функции changeSort. 
   
   Мы уже не в школе, поэтому не только запрограммируем алгоритм, но  и оценим его временную сложность. 
   За каждый проход массива минимум одно число занимает свое место, поэтому внешний цикл в худшем случае повторится (n – 1) раз. Внутренний цикл повторяется переменное число раз, от (n – 1) до 1 (как это было во всех ранее рассмотренных сортировках).
   Следовательно, приходим к той же оценке, что для сортировки выбором и сортировки вставками – O(n2).   
   Очевидное улучшение алгоритма – прекращать проходить массив, если в последнем проходе не было сделано ни одного обмена. Это позволит быстрее сортировать почти упорядоченные массивы, но не изменит оценку временной сложности в худшем случае.
  Метод sort
   Знание алгоритмов сортировки – не повод игнорировать метод массива sort, который способен отсортировать своего хозяина. В массиве могут быть числа.
   
var arr = [30, 20, 10, 60, 50, 40 ];
arr.sort();
alert(arr); // 10, 20, 30, 40, 50, 60
   Или строки.
   
var arr = ["bbb", "ccc", "aaa"];
arr.sort();
alert(arr);  // aaa, bbb, ccc
   Или вообще, все, что угодно. Метод sort сравнивает элементы сортируемого массива по отношению "<", а мы знаем, что разнотипные нечисловые значения при этом переводятся в строки и сравниваются как строки, т.е. в словарном порядке.
   Попробуем сортировать объекты.
   
var arr = [{x:20}, {x:30}, {x:10}];
arr.sort();
alert(arr); // [object Object],[object Object],[object Object]
   Неожиданный результат? Не совсем. Пользовательский объект по умолчанию переводится в строку «[object Object]». Мы ничего не сделали, чтобы изменить это правило (такого мы еще не проходили), вот метод sort и сравнивал одинаковые строки.
   Выходит, метод sort не всемогущ? 
   Всемогущ, всемогущ, потому что имеет необязательный параметр – функцию, которая задает ему алгоритм сравнения. Мы сами должны определить подходящую для целей сортировки функцию, но должны соблюсти следующие условия.
1. Функция имеет два параметра, назовем их a и b.
2. Функция возвращает:
   	- отрицательное число, если полагает, что a < b, 
   	- ноль, если a == b, 
   	- положительное число, если полагает, что a > b.
   Мы еще ни разу не передавали функцию в качестве аргумента, но сейчас попробуем.
    
   Пример 1. Отсортируем массив строк по возрастанию их длины, т.е. меньшей посчитаем ту строку, что короче.
   
   Сначала определим функцию, которая сравнивает две строки таким нестандартным образом. Имя функции может быть любым.
   
function comparer(a, b) {
   return a.length - b.length;
}
   Потом вызовем метод sort, передав ему эту функцию.
   
var arr = ["bbbbb", "cc", "aaa"];

arr.sort(comparer);

alert(arr);  // cc,aaa,bbbbb
   Как видите, чтобы передать функцию в качестве аргумента, достаточно указать ее имя.
   Имя указывать не обязательно, если аргументом метода sort сделать функциональное выражение, вот так:
   
var arr = ["bbbbb", "cc", "aaa"];

arr.sort( function (a, b) {
   return a.length - b.length;
});

alert(arr);  // cc,aaa,bbbbb
    
12.4. Отсортируйте числовой массив по убыванию, определив для этого функцию сравнения.
  Испытательный стенд
   Теория – это хорошо, но неплохо бы ее проверить на практике. Напишем программу для испытания разных методов сортировки. 
   Будем задавать размер массива, заполнять массив случайным образом, запускать функцию сортировки и засекать время. Это не только позволит убедиться, что сортировка – квадратичная, но и сравнить абсолютное время работы различных алгоритмов.
   Псевдослучайные числа
   Получить по-настоящему случайную последовательность чисел возможно, но это требует специального оборудования, в основе которого лежат вероятностные физические явления, такие как малые изменения плотности потока электронов или радиоактивный распад. В то же время легко получить последовательность чисел очень похожую на случайную. Очередной член такой псевдослучайной последовательности получается из предыдущего путем простых арифметических действий, например,
   	X = X * a % b, где a и b – константы.
   В объекте Math имеется метод random, который возвращает псевдослучайное число из интервала [0, 1). Заполнить массив псевдослучайными числами можно так.
   
var n = 10;    // размер массива
var arr = [];
for (var i = 0; i < n; i += 1)
    arr.push(Math.random()); 
   Псевдослучайные числа применяют в играх, для тестирования программ, есть даже математические методы, основанные на них. Например, при помощи функции Math.random можно приблизительно определить значение числа пи.
   Засечка времени
   Из браузера доступны многие системные функции, и одна из них – системный таймер. Если создать объект Date, вот так,
   
var d = new Date();
   то в нем "отпечатаются" текущие день, месяц, год, час, минута, секунда и даже миллисекунда. Впрочем, миллисекунды отпечатаются не очень точно. 
   У объекта даты есть метод getTime, который возвращает количество миллисекунд, прошедших с 1 января 1970 года. Если мы хотим измерить время работы функции selectSort, то должны сделать следующее:
   
var d1 = new Date();
selectSort(arr);
var d2 = new Date();
var msec = d2.getTime() - d1.getTime();
   Мы должны быть готовы к тому, что эта разность для маленьких массивов будет равна нулю, поэтому проводить измерение для n < 1000 не стоит. 
   Еще нужно принять во внимание, что операционная система одновременно выполняет множество задач, и процессор может отвлекаться на них во время наших испытаний. 
   Пользовательский интерфейс
   Пользователь должен иметь возможность задать размер массива, выбрать метод сортировки и увидеть результат испытания. 
   Размер будем задавать при помощи поля ввода, выбирать методы будем кнопками, результат в виде числа миллисекунд будем записывать в параграф.
   
<html>
<head>
</head>
<body>
    <h1>Испытательный стенд</h1>
    Размер массива
    <input type="text" id="size" value="1000">
    <p>
    <input id="selectSort" type="button" value="Выбором">
    <input id="arraySort" type="button" value="sort()">
    <p id="result">

    <script src="selectSort.js"></script>
    <script src="test.js"></script>
</body>
</html>
   В конце тела документа загружаются файлы кода: испытуемые алгоритмы сортировки (пока только один) и основная программа (test.js), которая показана ниже.
   
// Тестирование
function test(anySort) {
    var n = Number(document.getElementById("size").value);
    var arr = [];

    for (var i = 0; i < n; i += 1)
        arr.push(Math.random());

    var d1 = new Date();
    anySort(arr);
    var d2 = new Date();
    var msec = d2.getTime() - d1.getTime();

    document.getElementById("result").innerHTML =
        msec + " msec";
}

// Назначение обработчиков
document.getElementById("selectSort").onclick =
    function () {
        test(selectSort);
    };
document.getElementById("arraySort").onclick =
    function () {
        test(arraySort);
    };

// Стандартная сортировка
function arraySort(arr) { arr.sort(); }
   Программа состоит из трех секций. 
   В первой секции находится функция test, которая проводит испытание произвольной функции сортировки, переданной ей в качестве аргумента. Функции test создает массив, засекает время, вызывает полученную функцию сортировки, снова засекает время и показывает разницу в миллисекундах.
   Во второй секции назначаются обработчики нажатий на кнопки. Обработчики – это функциональные выражения, которые всего лишь вызывают функцию test с нужным аргументом. 
   В третьей секции стандартная сортировка массивов обернута в самодельную функцию arraySort. Прямо передать в функцию test ссылку на метод нельзя, поскольку метод вызывается не так, как вызывается функция.
   
12.5. Исключите из программы третью секцию (определение функции arraySort), заменив его функциональным выражением внутри второго обработчика.
12.6. Добавьте на стенд сортировку вставками и обменную сортировку.
  Заключение
1. Мы рассмотрели несколько алгоритмов сортировки и убедились, что их временная сложность одинакова – O(n2). Существуют более производительные алгоритмы сортировки, мы узнаем о них позднее.
2. Программируя сортировку, мы применили вспомогательную функцию. Это упростило код основной функции, но лишило программу компактности (стало две функции вместо одной). Вернуть компактность помогло вложение функций.
3. Ограничение видимости имен путем вложения их в определение функции позволяет избежать конфликта имен, поэтому широко практикуется программистами. JS не ограничивает глубину вложенности при определении функций. 
4. Каждый программист должен суметь написать программу, которая сортирует массив, но на практике следует использовать готовые средства, в частности, метод sort. Метод sort принимает в качестве необязательного аргумента функцию, задающую правило сравнения.
13. Рекурсия
  Рекурсивные определения
   Рекурсия давно известна в математике. Вот рекурсивное определение факториала:
   	n! = 1,            если n = 0;
   	n! = n (n-1)!,  если n > 0;
   Здесь факториал числа n определяется через факториал меньшего числа, n-1.
   А вот определение знакомого нам ряда Фибоначчи:  
   	f1 = f2 = 1;
   	fi =  fi -1 + fi - 2;
   Оно рекурсивно, т.к. любой член ряда, кроме первого и второго, определяется через два предыдущих члена этого ряда. 
   Вот рекурсивное определение НОД:
       НОД (а, b) = a,                         если b = 0  
       НОД (а, b) = НОД (b, a % b) , если b != 0  
   Заметим, что во всех определениях кроме рекурсивной части, есть и не рекурсивная часть, ее называют базой рекурсии. 
   В определении факториала это 0!
   	0! = 1;
   В определении ряда Фибоначчи это два первых члена ряда:
       f1 = f2 = 1;
   В определении НОД это наибольший общий делитель некоторого числа и нуля
       НОД (а, 0) = a.
   Если нет базы рекурсии, получается не определение, а порочный круг.
  Рекурсивные алгоритмы
   По рекурсивным определениям легко построить рекурсивные алгоритмы. Программируются эти алгоритмы при помощи функций, которые вызывают сами себя.
   Вычисление факториала
   Вернемся к рекурсивному определению факториала, немного изменив формулировку.

Если n = 0, 	
   n! = 1,          
иначе 
   n! = n * (n-1)!
   Теперь определим рекурсивную функцию factorial.
   
function factorial(n)
{ 
   if (n === 0)
       return 1;
   else 
       return n * factorial(n - 1);
}
// Проверка
alert(fact(4));  // 24
   Мы просто перевели рекурсивное определение с русского на JS и поместили его в тело функции.  
   Проследим, что происходит в памяти, на примере вычисления 4! (для наглядности имя функции factorial сокращено до одной буквы).
   
f(4)
f(4)=[4*f(3)]
f(4)=[4*f(3)]=[4*[3*f(2)]]
f(4)=[4*f(3)]=[4*[3*f(2)]]=[4*[3*[2*f(1)]]]
f(4)=[4*f(3)]=[4*[3*f(2)]]=[4*[3*[2*f(1)]]]=[4*[3*[2*[1*f(0)]]]]
f(4)=[4*f(3)]=[4*[3*f(2)]]=[4*[3*[2*f(1)]]]=[4*[3*[2*[1*1]]]]
f(4)=[4*f(3)]=[4*[3*f(2)]]=[4*[3*[2*1]]]
f(4)=[4*f(3)]=[4*[3*2]]
f(4)=[4*6]
24
   Строки диаграммы показывают состояние памяти программы. Каждая пара квадратных скобок – это незавершенный вызов функции. Все незавершенные вызовы функции сохраняют в памяти параметры и локальные переменные. Сначала количество незавершенных вызовов  растет, потом, по мере возврата из функций, сокращается.
   Максимальное число незавершенных вызовов называется глубиной рекурсии. Как и временную сложность, глубину рекурсии оценивают при помощи ее зависимости от количества входных данных. Для вычисления n! оценкой глубины рекурсии будет O(n), т.к. с каждым рекурсивным вызовом аргумент уменьшается на 1. 
  Временная сложность
   Для рекурсивных алгоритмов оценка временной сложности так же актуальна, как для обычных, тем более, что за внешней простотой рекурсивного алгоритма может скрываться большой объем вычислений.
   Рассмотрим рекурсивное вычисление n-го члена ряда Фибоначчи.
   
function fib(n) {
   if (n == 1 || n == 2)
      return 1;
   return fib(n – 1) + fib(n – 2);
}
    
   Если мы изобразим схему вызовов функции fib(n) в виде дерева и подсчитаем количество его узлов, то убедимся, что оно оценивается как O(2n). Такую же оценку имеет и временная сложность алгоритма, так как при каждом вызове выполняется не зависящее от n, постоянное число операций.
   
   Рисунок 13.1 – Схема вычисления fib(5)
   
   Экспоненциальная временная сложность лишает нашу функцию fib всякой практической ценности, поскольку алгоритм с циклом, применявшийся нами в разделе 3, имеет оценку O(n).
  Рекурсия и итерация
   Из теории известно, что всякий алгоритм можно записать и в рекурсивной, и в не рекурсивной, будем говорить, итеративной форме. Исключительно для упражнения перепишем уже известные нам итеративные функции в рекурсивной форме. 
   
   Пример 1. Показать с помощью функции alert целые числа от 1 до n.
   
   Сначала попробуем сформулировать решение словесно. 
   
   Чтобы показать числа от 1 до n, нужно:
1) показать числа от 1 до (n-1);
2) показать n.
   Но перед тем, как выполнять пункты 1) и 2), нужно проверить, не равно ли n единице. Если равно, нужно просто показать 1 и больше ничего не делать.
   
function showNumbers(n) 
{
    if (n == 1) 
        alert(1);
    else {
        showNumbers(n - 1);
        alert(n);
    }    
}
   Или более компактно.
   
function showNumbers(n) 
{
    if (n > 1) 
        showNumbers(n - 1);
    alert(n);    
}
   Пример 2. При помощи функции alert показать целые числа в обратном порядке, от n до 1.
   
function showNmbers(n) 
{
    alert(n);
    if (n > 1)
        showNumbers(n - 1);
}
   Пример 3. Показать поочередно цифры целого числа n в системе счисления с основанием b.
   
Рекурсивный алгоритм показа цифр можно сформулировать так.
Если n > 0, то:
1) напечатать младшую цифру числа;
2) уменьшить число, разделив его нацело на основание;
3) напечатать цифры уменьшенного числа.
   
function showDigits(n, b) 
{
    if (n > 0) {
        var d = n % b;
        var n1 = (n - d) / b;
        alert(d);
        showDigits(n1, b);
    }
}
   Цифры будут напечатаны, начиная с младшей. 
   
13.1. Показать поочередно цифры целого числа n, начиная со старшей. Добейтесь этого путем перестановки строк в теле функции showDigits.

   Пример 4. Найти минимальное число в массиве
   
   Обобщим поставленную задачу и будем искать минимальное число не во всем массиве, а на участке массива, начиная с i-го элемента и до конца. Поиск минимального числа во всем массиве будет частным случаем общей задачи при i = 0.
   Рекурсивный алгоритм может быть таким.
1. Если i = arr.length – 1, т.е. участок поиска состоит из одного единственного числа, то это число и есть минимальное.
2. Минимальное число на участке, который начинается с i, это меньшее из двух чисел: arr[i], и минимального числа на участке, начинающемся с  i+1.
   
function minInArray(arr, i)
{
    if (i == arr.length - 1)
       return arr[i];
    return Math.min(arr[i], minInArray(arr, i + 1));
}
13.2. Можно кардинально уменьшить глубину рекурсии, если делить область поиска пополам (как в бинарном поиске), а не отделять от нее по одному числу. Запрограммируйте этот вариант функции minInArray.
13.3. Определите рекурсивную версию функции binarySearch – двоичного поиска в массиве. Начните с рекурсивного определения результата поиска и оценки глубины рекурсии.
13.4. Запишите в рекурсивной форме алгоритм последовательного поиска.
13.5. Запишите в рекурсивной форме алгоритм обращения строки.
13.6. Предложите рекурсивный алгоритм для суммирования элементов массива.
  Задача о ханойских башнях
   Когда рекурсивный алгоритм содержит лишь один вызов самого себя, его легко переписать в итеративной форме.
   Если же рекурсивный алгоритм вызывает себя два или более раз, такой алгоритм труднее сделать итеративным, хотя это возможно – в конце концов, любая программа скомпилируется в машинный код, а у процессора нет рекурсивных команд. 
   Задача о ханойских башнях дает пример «существенно рекурсивного» алгоритма. 
   Условие
   Имеются три стержня. На первый стержень нанизаны n дисков в виде пирамидки. Переложить по одному все диски на третий стержень, используя второй стержень как промежуточный. Ни в какой момент перекладывания больший по диаметру диск не должен оказаться над меньшим. 
   
      
    
   Рисунок 13.2 – Ханойские башни
      
   Когда пирамидка состоит всего из двух дисков, решение очевидно: 
   (1, 2), (1, 3), (2, 3). 
   Эта запись означает: 
   переложить один диск с 1-го стержня на 2-й, 
   переложить один диск с 1-го стержня на 3-й, 
   переложить один диск со 2-го стержня на 3-й.
   
13.7. Запишите последовательность перекладываний для пирамидки из трех дисков.
   Общее решение
   Рекурсивный алгоритм решения таков. 
1. Переложить пирамидку из (n-1)-го диска с первого стержня на второй, используя третий стержень как промежуточный.
2. Переложить один диск, оставшийся на первом стержне, на третий.
3.  Переложить пирамидку из n-1 диска со второго стержня на третий, используя первый стержень как промежуточный.

Рисунок 13.3 – Решение задачи о ханойских башнях

   Реализация алгоритма при помощи рекурсивной функции показана ниже.
   
function hanoy(n, s1, s3) {
    if (n) {
        var s2 = 6 - s1 - s3;
        hanoy(n - 1, s1, s2);
        document.write("(" + s1 + ", " + s3 + "), " );
        hanoy(n - 1, s2, s3);
    }
}
   Функция имеет три параметра: n – количество дисков, s1 – стержень-источник, s3 – стержень-приемник. Выражение s2 = 6 - s1- s3; позволяет быстро определить номер промежуточного стержня.
   Чтобы увидеть всю цепочку перекладываний, вывод организован не функцией alert, а при помощи метода write объекта document.
   
   Замечание. Объект document, позволяет формировать html-страницу "на лету", просто выводя нужный текст и тэги, методом document.write.  Поскольку при первом вызове document.write все первоначальное содержимое страницы уничтожается, метод document.write не нашел у нас широкого применения.
   Анализ алгоритма
   Перекладывание пирамидки из n колец сводится к перекладыванию двух пирамидок из (n–1)-го кольца каждая, плюс постоянное время, C1, на перекладывание одного кольца.
       
       t(n) = 2 * t(n - 1) + C1;
       t(n-1) = 2 * t(n - 2) + C1;
       
   Подставим второе в первое и получим
       
       t(n) = 2 * (2 * t(n - 2) + C1) + C1 = 2 * 2 * t(n - 2) + C1 * (1 + 2);
       
   Продолжим подстановки.
       
       t(n) = 2k* t(n-k) + C1(1 + 2 + 22 + 2k-1) =  
       2n * t(0) + C1(1 + 2 + 22 +…+ 2n-1) = 2n * C + C1* (2n-1)
   
   Таким образом, временная сложность алгоритма – O(2n).
   Максимальная глубина рекурсии и количество требуемой памяти – O(n).
13.8. Даны маска m и строка s. Маска это строка из английских букв и звездочек, звездочка обозначает любую последовательность букв, в том числе пустую. Строка состоит только из английских букв. Определите рекурсивную функцию, которая возвращает true, если строка соответствует маске, и false – в противном случае.
  Быстрая сортировка
   Все алгоритмы сортировки, которые мы рассмотрели ранее, были квадратичными, т.е.  их временная сложность – O(n2), что существенно хуже теоретически возможного предела. Еще в 1960 году Чарльз Хоар предложил алгоритм сортировки, оценка которого близка к теоретическому пределу.
   Историческая справка
   Чарльз Энтони Ричард Хоар - английский ученый в области информатики и вычислительной техники. Один из разработчиков методологии структурного программирования и методов доказательства правильности программ. Работал над Algol-60. Работал в МГУ над машинным переводом под руководством  Колмогорова. 
   Получил премию Тьюринга 1980 г. – за достижения в разработке языков программирования.
   
   До того, как познакомиться с сортировкой Хоара, рассмотрим один вспомогательный алгоритм.
   Частичная сортировка
   Задача частичной сортировки – выбрать одно из чисел из массива (можно самое первое) и добиться того, чтобы все числа, которые меньше выбранного, предшествовали ему, а все числа, больше выбранного, следовали за ним. Это можно сделать по-разному, но наиболее экономный способ таков.
   
1. Выбираем первое число.
2. Проходя массив слева направо, останавливается на числе, которое больше выбранного.
3. Проходя массив справа налево, останавливается на числе, которое меньше выбранного.
4. Меняем найденные числа местами.
5. Повторяем пункты 2-4, продолжая движение с места остановки, пока текущая позиция «левого» просмотра не окажется правее текущей позиции «правого» просмотра. 
6. Меняем местами выбранное число и число в текущей позиции «правого» просмотра.
   Вот пример работы алгоритма. Выбранное число показано жирным шрифтом. Левая текущая позиция просмотра показана одинарным подчеркиванием, правая текущая позиция – двойным.
   
50  70  60  40  10  80  20  
50  20  60  40  10  80  70  
50  20  10  40  60  80  70  
40  20  10  50  60  80  70  
   Изложенный выше алгоритм частичной сортировки требует однократного прохождения массива, поэтому его временная сложность – O(n).
   
13.9. Запрограммируйте функцию частичной сортировки массива. Назовите ее partSort.
   Алгоритм сортировки Хоара
   Благодаря частичной сортировке, алгоритм сортировки Хоара выглядит довольно просто.
   
1. Если массив состоит из одного элемента, закончить работу.
2. Выполнить частичную сортировку массива, в результате чего массив делится на три части: в левой части находятся числа меньше выбранного, в середине – выбранное число, в правой  части – числа больше выбранного.
3. Применить к левой части массива алгоритм быстрой сортировки.
4. Применить к правой части массива алгоритм быстрой сортировки.

   Под словом «массив» следует понимать сортируемую область массива. Первоначально она действительно составляет весь массив.
   Рассмотренный алгоритм существенно рекурсивный, т.е. он вызывает себя более одного раза. Схема его вызовов – это дерево, подобное дереву, изображенному на рис.13.1. Уровни узлов дерева соответствуют уровням рекурсии.
   На каждом уровне рекурсии частичной сортировке подвергается в общей сложности не более, чем весь массив, т.е. не более, чем n чисел. Как мы уже установили, временная сложность частичной сортировки O(n). Уровней рекурсии – log2(n), т.к. длины сортируемых участков каждый раз сокращаются примерно вдвое (оценивая сложность бинарного поиска, мы установили, что число таких сокращений – log2 n).
   Следовательно, оценка временной сложности быстрой сортировки – O(n * log n).
   
13.10. Запрограммируйте рекурсивную функцию быстрой сортировки. Проверьте ее на испытательном стенде из предыдущего раздела книги.
   Медиана случайной выборки
   У рассмотренного алгоритма сортировки есть изъян. Если сортировать почти упорядоченный массив, время работы алгоритма катастрофически возрастает. В самом деле, если выбранное число самое маленькое или почти самое маленькое, то почти все элементы массива попадут в правую часть. Понадобиться не log2n, а n уровней рекурсии, чтобы исчерпать размер правой части, и общая оценка временной сложности возрастет до O(n2).
   Для практического устранения этого изъяна из сортируемой области массива случайным образом выбирают несколько чисел, и медиану этой выборки делают выбранным числом при частичной сортировке. 
   
   Замечание. Медианой множества чисел называется такое число m, что количество чисел, больших m, равно количеству чисел, меньших m. Например, медианой  множества {5, 8, 2, 9, 4} является число 5.
  Заключение
1. Многие понятия допускают рекурсивные определения. Рекурсивное определение всегда содержит базу рекурсии, без которой определение превращается в порочный круг.
2. Рекурсивные определения часто лежат в основе рекурсивных алгоритмов, поэтому построение алгоритма стоит начинать с рекурсивного определения.
3. Любую задачу можно решить и в рекурсивной, и в итеративной форме. Существенно рекурсивными являются функции, которые вызывают себя два и более раз.
4. Временная сложность сортировки Хоара близка теоретическому пределу для алгоритмов сортировки данных, на которые не наложено никаких ограничений. Какие-то специальные данные можно упорядочить и быстрее. 
14. Графика в HTML
   Современный HTML позволяет показывать в окне браузера не только текст и управляющие элементы, но и настоящую графику – пиксельные изображения, построенные из закрашенных и не закрашенных фигур. Можно быстро изменять эти изображения, добиваясь эффекта анимации. Все эти привлекательные вещи делаются при помощи JS.
  Элемент Canvas
   За размещение графики на HTML-странице отвечает элемент canvas. Вот пример страницы с элементом canvas на ней.
   
<!DOCTYPE html>
<html>
    <head>
        <script src="tryCanvas.js"></script>
    </head>
    <body onload="draw()">
        <canvas id="canvas1" width="600" height="400"></canvas>
    </body>
</html>
   Атрибуты width и height задают ширину и высоту прямоугольной области, занимаемой изображением. Единица измерения – пиксел.
   Закрывающий тэг у элемента canvas обязателен.
   Тэг script ссылается на файл tryCanvas.js с кодом рисования. Код рисования мы поместим в тело функции draw, а саму функцию сделаем обработчиком события  load объекта window. Это событие происходит, когда страница загружена и полностью готова к работе. 
   
function draw() {
   // ссылка на canvas
   var canvas = document.getElementById("canvas1");
   // контекст рисования
   var ctx = canvas.getContext("2d");
   // здесь будет код рисования…
}

window.onload = draw;
   В таком виде наш код успешно выполнится, где бы не находился тэг <script>, в конце тела, в начале тела или даже в заголовке страницы. Мы воспользуемся этим, чтобы еще больше разделить ответственность между частями нашей программы: тело html-страницы отвечает за пользовательский интерфейс, файлы с кодом отвечают за обработку событий, заголовок страницы отвечает за ссылки на файлы с кодом. 
   Итак, все, что мы хотим нарисовать, будет нарисовано немедленно после загрузки документа.
   Для рисования на канвасе нужно сослаться на элемент canvas, а затем получить ссылку на контекст – особый объект, свойства и методы которого дадут нам возможность рисовать.
   Параметр метода getContext, "2d", намекает на то, что контекст рисования предназначен для двумерной графики. Контексты для трехмерной графики существуют, но мы ограничимся двумерной.
  Прямоугольники
   Прямоугольник единственная фигура, которую контекст умеет рисовать целиком, все остальные фигуры строятся из отдельных линий. Для рисования прямоугольников у контекста имеются три метода:
   fillRect(x, y, width, height) – рисует закрашенный прямоугольник,
   strokeRect(x, y, width, height) – рисует контурный прямоугольник,
   clearRect(x, y, width, height) – очищает прямоугольную область.
   Параметры x и y – это координаты верхнего левого угла прямоугольника, width и height – его ширина и высота.
   
   Пример 1. Нарисовать два прямоугольника, один закрашенный, другой контурный.
   
function draw() {
    var canvas = document.getElementById("canvas1");
    var ctx = canvas.getContext("2d");

    ctx.fillRect(50, 50, 100, 100);
    ctx.strokeRect(10, 10, 100, 100);
}
   Координатная сетка канваса устроена так, что начало отсчета расположено в его верхнем левом углу, координата x возрастает слева направо, а координата y – сверху вниз. Единица измерения – пиксель.
   Хотя мы только начали осваивать графику, полученных сведений нам хватит для написания маленькой программы.
  Ковер Серпинского
   Мы живем в трехмерном пространстве, плоскость – пример двумерного пространства, линия – одномерного. Но есть математические объекты, которые имеют дробную размерность, например, 1.89. Один такой объект называется ковер Серпинского.
   Алгоритм построения
   Чтобы построить ковер Серпинского, нужно взять квадрат и разделить его на 9 равных частей, среднюю часть квадрата вырезать, а на оставшихся восьми маленьких квадратах построить восемь ковров Серпинского.
   
   
   
   Рисунок 14.1 – Ковер Серпинского
   
   Если продолжать так бесконечно долго, то получится тот самый таинственный объект с дробной размерностью. Мы же сможем построить лишь конечное приближение к нему. Для этого достаточно в изложенный рекурсивный алгоритм добавить базу рекурсии, например, такую: если сторона ковра меньше 1 пикселя, ковер не рисовать.
   Пользовательский интерфейс возьмем из примера 1. Функция рисования в файле tryCanvas.js будет такой.
   
var ctx;

function draw() {
    var canvas = document.getElementById("canvas1");
    ctx = canvas.getContext("2d");

    ctx.fillRect(0, 0, canvas.width, canvas.height);
    sierp(0, 0, canvas.width);
}
   Функция draw определяет ссылку на контекст рисования и сохраняет ее во внешней переменной, чтобы контекстом смогли воспользоваться и другие функции. Далее она заливает весь канвас черным цветом (цвет заливки по умолчанию черный) и вызывает рекурсивную функцию sierpinski, которая и построит ковер.

function sierpinski(x, y, z)
{
    if (z < 1) 
        return;
    z = z / 3;
    for (var row = 0; row < 3; row++) {
        for (var col = 0; col < 3; col++) {
            if (row == 1 && col == 1)
                ctx.clearRect(x + z, y + z, z, z);
            else
                sierpinski(x + col * z, y + row * z, z)
        }
    }
}
   Параметры x и y – это координаты верхнего левого угла ковра, а z – длина его стороны.
   
14.1. Программа будет интересней, если рисовать ковер поэтапно, по мере углубления в рекурсию. Сделайте так, чтобы при клике мышкой по канвасу добавлялся еще один уровень рекурсии.
Совет: не старайтесь приостанавливать процесс рисования. С каждым кликом рисуйте ковер заново, увеличивая на 1 глубину рекурсии.
14.2. С повышением уровня рекурсии время рисования быстро растет. Оцените временную сложность функции sierpinski. За n примите глубину рекурсии.
  Стиль линий и заливки
   По умолчанию цвет линий и заливки черный, ширина линии один пиксель, но это можно изменить при помощи следующих свойств контекста:
   fillStyle – цвет заливки, 
   strokeStyle – цвет линий,
   lineWidth – ширина линий.
   
   Пример 2. Нарисовать два прямоугольника, один закрашенный – красный, другой контурный – синий.
   
function draw() {
    var canvas = document.getElementById("canvas1");
    var ctx = canvas.getContext("2d");
    
    ctx.fillStyle = "red";
    ctx.strokeStyle = "blue";
    ctx.lineWidth = 5;

    ctx.fillRect(50, 50, 100, 100);
    ctx.strokeRect(10, 10, 100, 100);
}
   Цвет задается по правилам, принятым в CSS. 
   
   Замечание.  CSS (Cascading Style Sheets – каскадные таблицы стилей) – язык описания внешнего вида HTML-документа. Несмотря на чрезвычайную важность этого языка для дизайна web-страниц, в этой книге нам придется обойтись без него.
   
   Это может быть строка с названием цвета, шестиразрядное шестнадцатеричное число или функция, образующая цвет из трех или четырех компонент. Например, все нижеперечисленные команды устанавливают оранжевый цвет заливки.
   
ctx.fillStyle = "orange";
ctx.fillStyle = "#FFA500";
ctx.fillStyle = "rgb(255,165,0)";
ctx.fillStyle = "rgba(255,165,0,1)";
   Однажды установленные цвет заливки, цвет и ширина линий останутся таковыми впредь до их новой установки. 
   
14.3. Сделайте ковер Серпинского разноцветным. Цвета выбирайте по своему вкусу.
  Контуры 
   Теперь займемся контурными рисунками. 
   Контур (path) – это последовательность точек, соединенных между собой отрезками линий. Лини могут быть прямыми или кривыми. Чтобы нарисовать контур необходимо:
1) начать рисование контура методом контекста beginPath;
2) наполнить контур точками и линиями;
3) если необходимо, замкнуть контур методом closePath;
4) обвести или залить контур методом stroke или методом fill.
   Метод closePath соединяет последнюю и первую точку контура отрезком прямой. Если заливается незамкнутый контур, метод closePath вызывается неявно.
   Рисование прямых
   Простейшей линией является прямая. Рисование прямых обеспечивают два метода:
* moveTo(x, y) – переместить «перо» в точку (x, y);
* lineTo(x, y) – провести прямую из текущей точки в точку (x,y).

   Пример 3. Нарисуем треугольник.
   
    ctx.beginPath();
    ctx.moveTo(75, 50);    
    ctx.lineTo(100, 75);
    ctx.lineTo(100, 25);
    ctx.fill();
   Начальная точка контура (75, 50). Далее методом lineTo явно задаются две стороны треугольника, а третья получается автоматически в результате неявного замыкания контура. Цвет заливки по умолчанию черный.
   Когда контур заливается или прорисовывается, к нему применяются текущие параметры стиля: цвет заливки, цвет линии, ширина линии. Таким образом, все линии контура получаются одинаковой ширины и цвета.
   
14.4. Изобразите на канвасе салфетку Серпинского (рис. 14.2)



Рисунок 14.2 – Салфетка Серпинского.
  График функции
   Построим на канвасе график функции одной переменной. Пользовательский интерфейс оставим таким же, как в предыдущих примерах.
   Работу по рисованию графика будет выполнять функция chart. В качестве аргумента она получает функцию одной переменной, график которой мы собираемся строить.
   
function chart(f) {
    var canvas = document.getElementById("canvas1");
    var ctx = canvas.getContext("2d");

    ctx.beginPath();
    ctx.moveTo(0, f(0))
    for (var x = 0; x <= canvas.width; x++) 
        ctx.lineTo(x, f(x))
    ctx.stroke();
}
   График функции f строится в виде ломаной линии, звенья которой достаточно малы, чтобы линия казалась гладкой. Аргумент функции изменяется от 0 до ширины канваса.
   Остается вызвать функцию chart из функции draw, которая, как вы помните, является обработчиком события загрузки документа. 
   Для примера построим график функции sin(x).
   
function draw() {
    chart(Math.sin);
}
   В результате видим невзрачную пунктирную линию, идущую по верхней границе канваса. Вспоминаем, что значения функции sin(x) лежат в диапазоне [-1, 1], поэтому в системе координат канваса не будет видны отрицательные полуволны, а положительные, с амплитудой в 1 пиксель, покажутся лишь мелкой рябью вверху канваса. Чтобы увидеть настоящий график синуса необходимо увеличить масштаб изображения и сдвинуть его вниз.
   
function draw() 
{
    function f(x) {
        return -Math.sin(x / 20) * 150 + 200;
    }
    chart(f);
}
   Мы растянули ось абсцисс в 20 раз, ось ординат растянули в 150 раз и направили снизу вверх, начало координат сместили вниз на 200 пикселей.
  Создание новых функций
   Создание функций добавит в наш пример немного волшебства. 
   Как известно, функции в JS – это разновидность объектов. У них есть конструктор Function, который вызывают с двумя строковыми аргументами: в первой строке список параметров, во второй – тело функции.
   
var имя = new Function(параметры, тело);
   Вызов конструктора создает функцию с заявленными параметрами и телом. Фактически, вызов конструктора Function – это еще одна форма функционального выражения.
   Создадим новую функцию f в теле функции draw.
   
function draw() {
    var f = new Function(
        "x", 
        "return Math.sin(x / 20) * 150 + 200;");
    chart(f);
}
   Тело новой функции – это строка, а строку может ввести пользователь в текстовое поле ввода. Если пользователь введет правильное выражение, то наша программа послушно построит график соответствующей функции.

14.5. Напишите программу, которая получает от пользователя арифметическое выражение с переменной x и строит его график. Функцию рисования вызывайте по нажатию кнопки.
14.6. Сделайте так, чтобы пользователь мог задавать несколько выражений, а программа – строить несколько графиков. Графики рисуйте разными цветами.
  Текст
   На канвасе можно не только рисовать, но и писать. Текст при этом становится частью пиксельного изображения, поэтому очень мелкий шрифт выглядит не четким.
   Для изображения текста имеются два метода.
   
fillText(text, x, y [, maxWidth])

strokeText(text, x, y [, maxWidth])
   Строка текста выводится в прямоугольной области, левый нижний угол которой имеет координаты (x, y).  Опционально задается ширина области. Если ширина задана, и текст выходит за ее пределы, шрифт автоматически сжимается. 
   Шрифт для текста устанавливается свойством контекста font. Строка описания шрифта задается по правилам языка CSS.
   
ctx.font = "48px serif";
ctx.fillText("Hello world", 100, 100);
ctx.strokeText("Hello world", 100, 200);
14.7. Снабдите график произвольной функции осями координат, обозначениями осей и начала координат. 
  Заключение
1. Элемент canvas дает возможность рисовать на странице при помощи JS. Программный интерфейс рисования предоставляет контекст канваса.
2. Графическими примитивами контекста являются прямоугольники и контуры. Те и другие можно заливать цветом или обводить линией.
3. Контуры могут быть замкнутыми или открытыми. Открытые контуры, которые подвергаются заливке, замыкаются автоматически.
4. Ширина линии, цвет заливки и линий, а также шрифт задаются свойствами контекста. Заданные значения применятся при отображении графических примитивов до тех пор, пока не будут изменены.
15. Графическая программа
   В этом разделе мы напишем графическую программу, чтобы попрактиковаться не только в графике, но и в программировании.
  Решето Эратосфена
   Вы знаете, что простыми называются числа, которое имеют ровно два делителя – единицу и само число: 2, 3, 5, 7, 11, … У простых чисел много замечательных свойств, эти свойства изучает теория чисел. На очень  больших простых числах основана современная криптография.
   Существует несколько алгоритмов отбора простых чисел. Самый ранний из них, решето Эратосфена, приписывают Эратосфену Киренскому. 
   Историческая справка 
    Эратосфен Киренский (276–194 г. до н.э.) – греческий математик, астроном, географ, филолог и поэт. Работал директором Александрийской библиотеки.
   Первый доказал, что Земля имеет форму шара и с большой точностью определил ее радиус.  Он сделал это, измеряя в разных городах тени от солнечных часов, которые часы отбрасывали в астрономический полдень.
   
   Алгоритм Эратосфена позволяет найти все простые числа, не превышающие некоторого заданного целого числа n. Словесно алгоритм можно описать так.
1. Выписать подряд все целые числа от двух до n: 2, 3, 4, …, n.
2. Присвоить p = 2; (первое простое число).
3. Зачеркнуть в списке числа от 2p до n с шагом p (т.е. зачеркнуть 2p, 3p, 4p, …).
4. Найти первое незачёркнутое число в списке, большее чем p, и присвоить переменной p это число.
5. Повторять шаги 3 и 4, пока p < n.
   
   
   
   Рисунок 15.1 – Решето Эратосфена
   
   Для реализации алгоритма там потребуется массив из n элементов. Нет необходимости заполнять его числами, достаточно чтобы его элементы находились в одном из двух состояний: зачеркнутый или незачеркнутый. Первоначально все они равны undefined, пусть это означает «незачеркнутый». Если мы захотим вычеркнуть число i, просто присвоим i-ому элементу массива единицу. 
   Запрограммируем алгоритм Эратосфена в виде функции sieve, которая получает число n  и возвращает массив из n элементов с зачеркнутыми составными числами.
   
function sieve (n) {
    // массив из undefined
    var arr = new Array(n);

    for (var p = 2; p < n; )
    {
        // зачеркиваем числа, кратные p
        for (var i = 2 * p; i < n; i += p)
            arr[i] = 1;
        // находим первое незачеркнутое число
        for (p += 1; arr[p]; p += 1)
            ;
    }
    // числа 0 и 1 не простые 
    arr[0] = arr[1] = 1;
    return arr;
}
   Конструктор Array создает массив из n элементов. Все элементы равны undefined.
   Внешний цикл for осуществляет перебор простых чисел, начиная с 2. В заголовке внешнего цикла мы не видим привычного приращения управляющей переменной p. Его роль выполняет второй из вложенных циклов. Он тоже не совсем обычен, т.к. не содержит вложенной команды, все что нужно, выполняется в его заголовке. Чтобы показать, что мы намеренно опустили вложенную команду, на ее месте стоит точка с запятой.
   Распределение простых чисел
   Покажем результат просеивания чисел через решето Эратосфена. Для этого изобразим числовой массив на канвасе в виде черных и белых клеток. Невычеркнутые элементы, индексы которых и есть простые числа, покажем в виде черных клеток, вычеркнутые элементы  (индексы которых являются составными числами) – в виде белых. Клетки будем рисовать рядами, чтобы занять всю площадь канваса.
   Параметром программы сделаем количество клеток в ряду. Размер клетки определим автоматически, разделив ширину канваса на число клеток в ряду.
   Пользовательский интерфейс программы изображен на рис.15.2.
   
   
   
   Рисунок 15.2 – Пользовательский интерфейс решета Эратосфена
   
   Он состоит из поля для ввода количества клеток в ряду и кнопки Draw, которая дает команду рисовать. Дополнительный бонус будет в том, что можно кликнуть мышкой по любой клетке и увидеть, какое за ней число.
   Программу составим из нескольких функций. Одна из них – уже знакомая нам функция sieve. Ее задача получить массив, в котором «не вычеркнуты» простые числа.
   Другая функция называется init. Ее задача – инициализировать несколько глобальных переменных, необходимых другим функциям. 
   Глобальные переменные – важная часть программы. Они упрощают код функций и позволяют им взаимодействовать между собой. В то же время глобальные переменные таят угрозу ошибок, которые трудно обнаружить, поэтому их число стараются свести к минимуму.
   В нашей программе будет пять глобальных переменных: canvas – ссылка на канвас, cols – количество клеток в ряду (иначе говоря, количество колонок), size – размер клетки, rows – количество рядов, которые поместятся на канвасе и primes – массив, который возвращает функция sieve.
   
// глобальные переменные
var canvas, cols, rows, size, primes;

function init() {
    canvas = document.getElementById("canvas1");
    cols = +document.getElementById("cols").value;
    size = canvas.width / cols;
    rows = Math.round(canvas.height / size);
    primes = sieve(cols * rows)
}
   Функция draw изображает расположение простых чисел в виде закрашенных клеток. 
   
function draw() {
    var ctx = canvas.getContext("2d");
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (var r = 0; r < rows; r++) {
        for (var c = 0; c < cols; c++) {
            var i = r * cols + c;
            if (!primes[i]) {
                ctx.fillRect(c * size, r * size, size, size);
            }
        }
    }
}
   Поскольку рисование клеток возможно только после инициализации глобальных переменных, вызов функции init должен предшествовать вызову функции draw. Закрепим это правило в определении еще одной функции – show.
   
function show() {
    init();
    draw();
}
   Итак, все функции и переменные готовы, остается позаботиться об обработке событий. Во-первых, после загрузки страницы мы хотели бы видеть распределение простых чисел для начального значения cols = 12. И мы знаем, как этого достичь – в основной программе выполнить команду:
   	window.onload = show;
   Во-вторых, пересчет размеров и рисование должны выполняться при каждом нажатии на кнопку с надписью «Draw».
   	document.getElementById("btn").onclick = show;
   
   Но куда поместить эту команду? Если рядом с первой, она не сработает, потому что во время выполнения основной программы модель документа еще не будет достроена, и кнопка не будет найдена.
   Выход в том, чтобы назначение обработчиков других событий выполнять в обработчике события window load.
   Весь код, написанный выше, находятся в файле eratosthenes.js. 
   
// глобальные переменные
var canvas, cols, rows, size, primes;

function sieve(n) {
    var arr = new Array(n);
    arr[0] = arr[1] = true;
    for (var step = 2; step < n; step += 1)
        for (var i = 2 * step; i < n; i += step)
            arr[i] = true;
    return arr;
}

function init() {
    canvas = document.getElementById("canvas1");
    cols = +document.getElementById("cols").value;
    size = canvas.width / cols;
    rows = Math.round(canvas.height / size);
    primes = sieve(cols * rows);
}

function draw() {
    var ctx = canvas.getContext("2d");
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (var r = 0; r < rows; r++) {
        for (var c = 0; c < cols; c++) {
            var i = r * cols + c;
            if (!primes[i]) {
                ctx.fillRect(c * size, r * size, size, size);
            }
        }
    }
}

function show() {
    init();
    draw();
}

// основная программа

window.onload = function () {
    document.getElementById("btn").onclick = show;
    show();
}
   HTML-страница программы показана ниже.
   
<!DOCTYPE html>
<html>
    <head>
         <script src="eratosthenes.js"></script>
    </head>
    <body>
        Columns <input type="text" id="cols" value="12" />
        <input type="button" id="btn" value="Draw" />
        <p />
        <canvas id="canvas1" width="500" height="500"></canvas>
    </body>
</html>
  Объект event
   О событиях, которые мы обрабатывали до сих пор (окончание загрузки документа, нажатие на кнопку), нам не требовалось никакой дополнительной информации, достаточно было знать, что они произошли. Тем не менее, всякий раз, когда происходит событие, браузер создает особый объект и записывает в него исчерпывающую информацию о событии. Если это событие мыши, будут записаны координаты курсора мыши и какая кнопка мыши нажата, если событие клавиатуры, будет записан номер клавиши и текущее состояние клавиш Alt, Ctrl и Shift и т.д. Ссылку на этот ценный объект браузер помещает в свойство window.event.
   Пусть мы хотим, чтобы при клике мышью по любому черному квадрату на странице появлялось простое число, которое представлено этим квадратом. Событие, которое нам следует обработать, – это mousedown для канваса. Это событие происходит в момент нажатия кнопки мыши, когда курсор мыши находится над канвасом. Функция-обработчик должна определить строку и столбец, в которых расположен данный квадрат. Для этого достаточно знать координаты курсора мыши в системе канваса, а размер стороны квадрата уже записан в переменной size.
   Координаты курсора мыши в момент нажатия на кнопку мыши сохранены в свойствах clientX и clientY объекта event. Но это координаты в системе страницы, поэтому к ним нужно добавить смещение канваса по отношению к верхнему и к левому краям страницы (рис. 15.3)
   
   
   
   Рисунок 15.3 – Координаты курсора мыши
   
   За показ простого числа  отвечает отдельная функция, showNumber.
   
function showNumber() {
    var x = event.clientY - canvas.offsetTop;
    var y = event.clientX - canvas.offsetLeft;
    var row = Math.floor(x / size);
    var col = Math.floor(y / size);
    var i = row * cols + col;
    document.getElementById("num").innerHTML = " " + i;
} 
   Последняя команда функции показывает значение переменной i в элементе с id = "num".
   
<span id="num"></span>
   Не забудьте поместить его на html-страницу, можно сразу за кнопкой.
   Чтобы сделать функцию showNumber обработчиком события канваса mousedown, добавим одну команду в функцию window.onload.
   
window.onload = function () {
    document.getElementById("btn").onclick = show;
    show();
    canvas.onmousedown = showNumber;
}
15.1. Переключите функцию showNumber на обработку события mousemove. Сделайте так, чтобы число появлялось при прохождении курсора мыши только по черному квадрату, а при прохождении по белому не появлялось. 
  Скатерть Улама
   Скатерть Улама была открыта случайно в 1963 году – американским математиком Станиславом Уламом. Коротая время скучного доклада, на котором ему довелось присутствовать, он начертил на листке бумаги вертикальные и горизонтальные линии и стал нумеровать клетки: в центре поставил единицу, затем, двигаясь по спирали, двойку, тройку и т. д. При этом он отмечал простые числа. Оказалось, что многие простые числа выстроились вдоль диагональных прямых.
   
      
    
       Рисунок 15.4 – Скатерть Улама       
   
   Чтобы воспроизвести скатерть Улама на канвасе, нам понадобится функция, которая расставит натуральные числа по спирали. Расставлять можно прямо на канвасе, но тогда задача расстановки будет переплетена с задачей рисования, и мы нарушим правило, которое гласит, что одна функция должна решать одну задачу.
   Пусть функция расстановки, назовем ее spiral, получит количество чисел, n, и вернет нам массив пар [[0, 0], [1, 0], [1, -1], [0, -1], [-1, -1], [-1, 0],…]. 1-я пара этого массива содержит координаты единицы, вторая – координаты двойки, третья – тройки и т.д., n-я пара содержит координаты числа n. Пара – это тоже массив, только маленький, из двух элементов. Координатами клетки будем считать номер столбца и номер строки. Условимся, что номера строк возрастают сверху вниз, а номера столбцов слева направо.
   
   Рисунок 15.5 – Числа – по спирали
   
   Определить такую функцию нам поможет рис. 15.5, из которого видно, что квадрат можно покрыть слоями, в каждом слое по четыре линейки чисел, длины линеек от слоя к слою увеличиваются на два и составляют: 2, 4, 6, …
   
15.2. Определите функцию spiral(n).
   
   Если вам удалось выполнить предыдущее задание, вы, несомненно,  сможете самостоятельно закончить программу Скатерть Улама. 
   Пользовательский интерфейс программы возьмите из Решета Эратосфена, число в текстовом поле cols будет количеством клеток на стороне скатерти.
  Заключение
1. До изобретения объекно-ориентрованного программирования программы состояли из функций и глобальных переменных, разделяемых всеми функциями. Решето Эратосфена является примером такой программы.
2. Проектируя функции нужно придерживаться правила: "Одна функция – одна задача". Нарушение этого правила делает код негибким и непонятным. 
3. Информацию о любом событии браузер упаковывает в объект window.event, там ее сможет найти функция-обработчик события.
16. Изображения и трансформации
   На канвас можно выводить не только прямоугольники и контуры, но и пиксельные изображения. Для вывода изображения, во-первых, нужно создать объект изображения, во-вторых, нужно вызвать метод контекста drawImage, который перенесет содержимое объекта на канвас.
  Рисование изображений
   Источником изображения может служить внешний файл, элемент img или другой элемент canvas на этой странице.
   Изображение из элемента img
   Пример 1. В этом примере источником изображения является элемент img на той же странице, где и canvas.
   
<!DOCTYPE html>
<html>
<head>
    <script src="images.js"></script>
</head>
<body>
    <canvas id="canvas1" width="600" height="400"></canvas>
    <img src="JS.png" id="img1" />
</body>
</html>
   
Код из файла images.js рисует изображение на канвасе. 
   
window.onload = function() {
    var canvas = document.getElementById("canvas1");
    var ctx = canvas.getContext("2d");

    var img = document.getElementById("img1");
    ctx.drawImage(img, 0, 0);
}
   Мы упразднили имя функции, сделав функциональное выражение обработчиком события  window load.
   Собственно вывод изображения выполняет метод контекста drawImage(img, x, y), где x и y – координаты верхнего левого угла изображения в системе координат канваса. 
   Теперь на нашей странице два изображения, одно в элементе img, другое на канвасе. При желании элемент img можно сделать невидимым, например, задав ему нулевую ширину.
   
<img src="JS.png" id="img1" width="0"/>
   Изображение из файла
   Источником изображения может быть файл любого графического формата из тех, что понимает браузер (PNG, GIF, JPEG,…).
    
   Пример 2. Элемент img не содержится в исходном документе, а создается в коде JS.
   
window.onload = function() {
   var canvas = document.getElementById("canvas1");
   var ctx = canvas.getContext("2d");

   var img = new Image();
   img.src = 'JS.png';

   ctx.drawImage(img, 0, 0);
}
   Код прост и понятен, но он не работает, потому что между созданием и рисованием изображения проходит слишком мало времени. Файл с изображением, JS.png, не успевает загрузиться, и созданный объект img, подобно скорлупе пустого ореха, не имеет содержания. 
   Выход в том, чтобы привязать рисование к событию, которое выполнится после того, как файл изображения будет загружен. В этом смысле подходящим является событие load того же элемента img.
   Исправленный код функции draw будет таким.
   
window.onload = function() {
   var canvas = document.getElementById("canvas1");
   var ctx = canvas.getContext("2d");

   var img = new Image();
   img.src = 'JS.png';

   img.onload = function () {
       ctx.drawImage(img, 0, 0);
   };
}
   Дополнительные возможности вывода изображений
   Основная задача метода drawImage – выводить изображения на канвас. Но он может не только выводить, но и масштабировать изображение.
   
drawImage(image, x, y, width, height)
   Параметры width и height – это ширина и высота изображения на канвасе.
   Третий вариант вызова drawImage позволяет вырезать из источника прямоугольную область и перенести ее в прямоугольную область канваса. Если размеры областей не совпадают, происходит масштабирование.
   
drawImage(image, sx, sy, sWidth, sHeight, 
                 dx, dy, dWidth, dHeight) 
   Параметры sx, sy, sWidth, sHeight задают область источника (s – source), параметры dx, dy, dWidth, dHeight задают область приемника (d –destination).
   
   
   Рисунок 16.1 – Девять аргументов метода drawImage
   
16.1. Найдите в интернете изображения темного и светлого шпона и нарисуйте на канвасе шахматную доску.
  Трансформации
   Все координаты в методах графического вывода задаются в системе координат канваса. Если изменить эту систему, изменится и вид выводимых фигур. Например, если растянуть ось Ox в два раза, то прямоугольник шириной в 100 пикселей на канвасе займет 200. Изменения системы координат канваса называются трансформациями, и сейчас мы их рассмотрим.
   Перенос
   Перенос начала координат осуществляется методом контекста
       translate(x, y); 
   где x и y – новое положение начала координат.
   
   Пример 3. Нарисуем два квадрата, белый – в исходной системе координат, черный – в системе координат, перенесенной в точку (50, 25). Файл HTML-страницы таков.
   
<!DOCTYPE html>
<html>
<head>
    <script src="transforms.js"></script>
</head>
<body>
    <canvas id="canvas1" width="600" height="400"></canvas>
</body>
</html>
   В файле transforms.js демонстрационный код, как всегда,  поместим в обработчик события window load.
   
window.onload = function() {
    var canvas = document.getElementById("canvas1");
    var ctx = canvas.getContext("2d");

    ctx.strokeRect(0, 0, 100, 100); // белый квадрат
    ctx.translate(50, 25);
    ctx.fillRect(0, 0, 100, 100);   // черный квадрат
}
Результат можно увидеть на рисунке 16.2 а).


   Рисунок 16.2 –  Трансформации
   Поворот   
   Поворот системы координат выполняется вокруг точки (0, 0) по часовой стрелке. Угол поворота измеряется в радианах. 
   Поворот выполняется методом
       rotate(angle);
   
   Пример 4. Нарисуем два прямоугольника, один до поворота системы координат, другой – после. Воспользуемся HTML-страницей из примера 3, изменим только код в файле transforms.js.
   
window.onload = function() {
    var canvas = document.getElementById("canvas1");
    var ctx = canvas.getContext("2d");

    ctx.strokeRect(0, 0, 100, 100); // белый квадрат
    ctx.rotate(Math.PI/6);
    ctx.fillRect(0, 0, 100, 100);   // черный квадрат
}
   Результат выполнения кода показан на рисунке 16.2 б).
   Если нужно повернуть систему осей вокруг иной точки, поворот нужно сочетать с переносом. 
   
   Пример 5. Повернем квадрат (50, 50, 100, 100) вокруг его центра, т.е. вокруг точки (100, 100), на 45o.
   
function draw() {
    var canvas = document.getElementById("canvas1");
    var ctx = canvas.getContext("2d");

   ctx.strokeRect(50, 50, 100, 100);  // белый квадрат

    // перенос
   ctx.translate(100, 100);
    // поворот на 45o
   ctx.rotate(Math.PI / 4);
    // обратный перенос
   ctx.translate(-100, -100);

   ctx.fillRect(50, 50, 100, 100);  // черный квадрат }
Результат показан на рисунке 16.2 в).
   Масштабирование
   Масштабирование производится методом контекста
   scale(kx, ky);
   где kx и ky – коэффициенты масштабирования вдоль осей Ox и Oy.
   Если коэффициент больше единицы, происходит растяжение оси, если меньше – сжатие.
   
   Пример 5. Нарисуем два одинаковых по форме прямоугольника, но второй в два раза растянем по горизонтали и в два раза сожмем по вертикали.
   
function draw() {
    var canvas = document.getElementById("canvas1");
    var ctx = canvas.getContext("2d");
    ctx.strokeRect(50, 50, 100, 100);
    ctx.scale(2, 0.5);
    ctx.fillRect(50, 50, 100, 100);
}
Результат показан на рисунке 16.2 г).
   Сохранение и восстановление состояния
   Состояние канваса в любой момент можно сохранить методом контекста save. Состояние включает в себя все параметры канваса: цвет, стиль и ширина линий, цвет закраски, шрифт, выравнивание текста и все прочее, включая трансформации.
   Восстановить сохраненное состояние можно методом контекста restore.
   Сохранять и восстанавливать состояние можно многократно, но есть правило: первым будет восстановлено то состояние, которое сохранено последним.
  Стрелка компаса
   Рассмотрим пример, в котором используем полученные знания о выводе изображений, трансформации, сохранении и восстановлении состояния канваса.
   Поместим в центре канваса изображение стрелки компаса, направленной на север (север у нас вверху страницы). При появлении курсора мыши в области канваса стрелка должна начать указывать на курсор мыши.
   
<!DOCTYPE html>
<html>
<head>
    <script src="compass.js"></script> 
</head>
<body>
    <canvas id="canvas1" width="600" height="400" ></canvas>
    <img id="img1" src="compass.png" width="0"/>
</body>
</html>
   Источником изображения нам послужит невидимый (благодаря нулевой ширине) элемент img. Изображение из файла compass.png показано на рис. 16.3. 
   
   
   
   Рисунок 16.3 – Стрелка компаса
   
   В файле compass.js располагается основная программа и две функции. Начнем с основной программы. Как обычно, она состоит из назначения обработчика события load объекта window. 
   
window.onload = function () {
   // нарисовать стрелку, направленную на север
   draw(-Math.PI / 2);

   // задать обработчик события canvas mousemove
   document.getElementById("canvas1").onmousemove = 
      function () {
         var angle = getAngle(event);
         drawArrow(angle);
      };
};
   Как только страница загрузится, будет нарисована стрелка, направленная на север, и задан обработчик для события перемещения курсора мыши по канвасу. При каждом перемещении курсора определяется угол поворота стрелки и рисуется стрелка, повернутая на этот угол.
   Задачу определения угла поворота стрелки возложена на метод getAngle. Параметром метода является объект события.
   
function getAngle(e) 
{
    var canvas = document.getElementById("canvas1");
    var center = { x: canvas.width/2, y: canvas.height/2 };
    var x = e.clientX - canvas.offsetLeft;
    var y = e.clientY - canvas.offsetTop;

    return Math.atan2(y - center.y, x - center.x);
}
   Для определения угла достаточно знать координаты двух точек: первой – центра канваса, в котором находится ось вращения стрелки, второй – точки на канвасе, в которой находится курсор мыши.
   Угол в радианах возвращает функция Math.atan2.
   
   Рисование стрелки, повернутой на угол angle, выполняет метод drawArrow (angle).
   
function drawArrow(angle)
{
   var canvas = document.getElementById("canvas1");
   var ctx = canvas.getContext("2d");

   var center = {x: canvas.width / 2, y: canvas.height / 2};
   var img = document.getElementById("img1");

   ctx.clearRect(0, 0, canvas.width, canvas.height);
   ctx.save();
   ctx.translate(center.x, center.y);
   ctx.rotate(angle);
   ctx.drawImage(img, 
      -img.naturalWidth / 2, -img.naturalHeight / 2);
    ctx.restore();
}
   Первые две команды – это стандартное определение ссылки на контекст.
   Объект center представляет центральную точку канваса, она будет осью вращения стрелки. 
   Рисование начинается с очистки всей поверхности канваса методом ctx.clearRect.
   Прежде, чем начать трансформации системы координат сохраняем ее текущее состояние методом ctx.save.
   Перемещаем начало координат в центр канваса (т.е. в точку, где будет находится ось стрелки), поворачиваем оси координат на угол angle, и выводим изображение стрелки с таким сдвигом влево-вверх, чтобы центр стрелки совместился с началом координат (рис.16.4).
   
   
   
   Рисунок 16.4 – Трансформации стрелки компаса
   
   После вывода изображения восстанавливаем исходное состояние системы координат методом ctx.restore. Сохранение и последующее восстановление состояния канваса позволяет нам не накапливать трансформации, а выполнять их заново всякий раз, когда потребуется нарисовать стрелку.
   
16.2. Напишите программу, которая рисует циферблат часов, часовую и минутную стрелки. Часы должны показывать время, заданное в текстовом поле ввода, например, "9:45".
  Заключение
1. Чтобы нарисовать изображение на канвасе, нужно сначала получить или создать объект изображения. Рисовать изображение можно только после того, как завершится процесс загрузки изображения из файла или из сети.
2. Трансформация – это изменение системы координат канваса. Возможны перенос, поворот и масштабирование осей координат.  Итоговая трансформация является суммой всех предыдущих трансформаций.
3. Помимо цвета линий, толщины линий и цвета заливки, состояние канваса включает в себя суммарную трансформацию системы координат. Состояние канваса можно сохранять и восстанавливать.
17. Таймер и анимация
   Таймер в JS позволяет вызывать функции не сразу, а "по расписанию". Составить расписание можно при помощи двух функций – setTimeout и setInterval.
  Отложенный вызов
   Функция 
       setTimeout(функция, задержка);
   запускает таймер, который отсчитает заданную задержку и после этого вызовет целевую функцию.  Задержка задается в миллисекундах.
   
   Пример 1.  Сделать так, чтобы через две секунды открылось окно alert со словом "Время истекло".
   
setTimeout(function() { alert('Время истекло') }, 2000);
   У функции setTimout могут быть дополнительные аргументы, которые станут аргументами вызываемой функции.
   
   Пример 2. Спустя одну секунду сложить два заданных числа и показать результат в окне alert.

function f(x, y) {
  alert(x + y);
}

setTimeout(f, 1000, 2, 3);   // 5
Функция setTimeout возвращает идентификатор таймера, который позволит, отменить вызов целевой функции, если это понадобится.
   
var timerId = setTimeout(f, 1000, 2, 3);  
clearTimeout(timerId);
В итоге вызов f(2, 3) не состоится.
  Периодические вызовы
   Функция 
       setInterval(функция, интервал);
   запускает таймер, который будет периодически, через заданный интервал времени, вызывать целевую функцию. Интервал задается в миллисекундах. Возвращает функция идентификатор таймера.
   
   Пример 3. Сделать так, чтобы через каждые полсекунды на странице прибавляется смайл.
   
var timerId = setInterval(
   function func() {
      document.write(":) ");
   }, 500);
   Прекратить периодические вызовы целевой функции можно, вызвав функцию clearInterval с идентификатором таймера.
   
clearInterval(timerId);

17.1. Сделайте так, чтобы появление смайлов на странице прекращалось спустя 5 секунд после появления первого смайла.
17.2. Периодические вызовы можно организовать при помощи рекурсивного вызова setTimeout из целевой функции. Перепишите пример со смайлами, не используя функцию setInterval.
  Анимация на канвасе
   Если с достаточной частотой рисовать что-либо на канвасе, внося в рисунок небольшие изменения, у зрителя возникнет иллюзия непрерывного движения. 
   
   Пример 4. Показать на канвасе движущийся шар.
   Для начала выведем на канвас неподвижное изображение шара.
   
<!DOCTYPE html>
<html>
<head>
   <script src="balls.js"></script> 
</head>
<body>
    <canvas id="canvas1" width="600" height="400" >
    </canvas>
    <img id="img1" src="ball.png" width="0"/>
</body>
</html>
   
window.onload = function() {
    var canvas = document.getElementById("canvas1");
    var ctx = canvas.getContext("2d");
    var img = document.getElementById("img1");
    
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(img, 0, 0, 100, 100);
}
   Чтобы заставить шар двигаться, достаточно периодически выполнять две последних команды, понемногу меняя координаты изображения шара.
   
window.onload = function() {
    var canvas = document.getElementById("canvas1");
    var ctx = canvas.getContext("2d");
    var img = document.getElementById("img1");

    var x = 0, y = 0;
    setInterval(function () {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, x++, y++, 100, 100);
    }, 10);
} 
   Шар поедет вправо вниз и быстро исчезнет с канваса. Это произойдет потому, что логика его движения слишком примитивна. Хорошо бы остановить его у края канваса, или заставить отражаться от стенок, или постепенно замедлять движение, или испытывать "притяжение земли" или все это вместе. Но прежде, чем усложнять логику поведения шара, нужно отделить ее от процесса рисования, иными словами, разделить ответственность.
  Программа Balls
   Модель
   Текущие координаты и скорость шара, правила, которым подчиняется его поведение, – все это является моделью реальной ситуации. Программные объекты, отвечающие за состояние шара и его поведение, составят модель предметной области или коротко – модель.
   В нашем примере моделью будет объект ball и функция step. Oбъект ball ответственен за состояние шара: его координаты – это свойства x и y, скорость – свойства vx и vy,  диаметр – свойство d.
   
var ball = { x:100, y:100, vx:1, vy:1, d:100};
   Точный смысл всех свойств объекта ball передает рисунок 17.1.
   
   Рисунок 17.1 – Свойства объекта ball
   
   Движение складывается из множества малых шагов. За один шаг шар, обладающий скоростью v, изменяет свое положение в пространстве по закону 
       x = x + vx * t. 
       y = y + vy * t. 
   Это справедливо, при условии, что отрезок времени t мал, и скорость за это время не успевает заметно измениться.
   Один шаг объекта ball выполняет функция step. 
   
function step(b) {
    b.x += vx;
    b.y += vy;
}
   Время анимации измеряется в шагах (т.е. в количествах вызовов функции step), поэтому вполне естественно полагать, что за один шаг проходит время t = 1.
   Представление 
   Представление модели на экране компьютера – это отдельная задача, и отвечать за нее будет объект canvas и функция draw.
   
function draw(b) {
    var canvas = document.getElementById("canvas1");
    var ctx = canvas.getContext("2d");
    var img = document.getElementById("img1");

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(img, b.x, b.y, b.d, b.d);
}
   Текущее состояние модели функция draw получает в виде аргумента – объекта ball.
   На долю главной функции остается создать объект ball и начать движение.
   
function main() {
    var ball = { x:100, y:100, vx:1, vy:1, d:100};

    setInterval(function () {
        step(ball);
        draw(ball);
    }, 10);            
}

window.onload = main;
   Подведем промежуточный итог. В нашей программе есть две части: модель и представление. Модель, состоит из объекта ball и функции step, которая перемещает объект ball на один шаг. Представление модели на экране обеспечивают объект канвас и функция draw. 
   Подготовительные операции – создание модели и запуск движения – выполняет функция main. Она вызывается, когда все необходимые элементы страницы (канвас, изображение шара) будут приведены в состояние готовности.  
   Данную версию программы назовем Balls 1.0.
  Развитие программы
   Теперь можно выдвигать дополнительные требования и усложнять программу, не рискуя превратить ее в спагетти-код. 
   
   Замечание. Спагетти-код назван так, потому что ход выполнения программы похож на миску спагетти, то есть извилистый и запутанный. (Википедия)
   
   Добьемся того, чтобы шар отражался от стенок канваса подобно бильярдному.
   Законы механики таковы, что при отражении от вертикальной стенки составляющая скорости vy остается неизменной, а составляющая vx меняет знак на противоположный. Отражение от горизонтальной стенки, напротив, сохраняет составляющую vx и меняет знак составляющей vy. Все это следует учесть в функции step.
   
function step(b) {
    // изменение скорости при отражении от вертикальной стенки  
    if (b.x < 0 || b.x + b.d > 600)
        b.vx = -b.vx;
    // изменение скорости при отражении от горизонтальной стенки  
    if (b.y < 0 || b.y + b.d > 400)
        b.vy = -b.vy;
    // изменение координат
    b.x += b.vx;
    b.y += b.vy;
}
   Числовые значения в коде функции step, как и в любом коде, крайне нежелательны. Они лишают функцию гибкости, делают код менее понятным и создают ненужные зависимости. В данном случае смысл чисел 600 и 400 – ширина и высота прямоугольника, внутри которого перемещается шар, поэтому добавим в нашу модель еще один объект – прямоугольник. И кстати, его размер совсем не обязан совпадать с размером канваса.
   
function main() {
    var ball = { x: 100, y: 100, vx: 1.5, vy: 0.5, d: 100 };
    var rect = { w: 300, h: 200 };

    setInterval(function () {
        step(ball, rect);
        draw(ball, rect);
    }, 10);            
}
   Новый объект должен быть учтен функцией step и функцией draw.
   
17.3. Модифицируйте код функции step так, чтобы шар отражался от стенок прямоугольника rect.
17.4. Модифицируйте код функции draw так, чтобы прямоугольник rect был виден на рисунке.

   Программе, которая получится после выполнения заданий, дадим имя Balls 1.1.
  Заключение
1. Отложенные и периодические вызовы не задерживают исполнение кода, т.е. функции setTimeout и setInterval тотчас возвращают управление. Но они отодвигают во времени момент вызова целевой функции.
2. Есть несколько способов сделать анимацию на html-странице. Мы рассмотрели один из них – анимацию на канвасе при помощи JS. Этот способ нуждается в функциях setInterval и setTimeout.
3. Правильно спроектированная программа должна состоять из относительно независимых частей. В небольших программах такими частями могут быть модель предметной области и визуальное представление модели.
18. Объектное программирование
   Добавим в программу Balls новые возможности. Поместим внутрь прямоугольника, в дальнейшем будем называть его контейнером, не один шар, а массив шаров.
   Но если прямоугольник, не просто растянутый квадрат, а контейнер для шаров, будет правильно, если массив шаров будет его свойством. Вот пример контейнера с тремя шарами внутри.
   
var b1 = { x: 0, y: 0, vx: 1.5, vy: 0.5, d: 50 };
var b2 = { x: 300, y: 200, vx: 0.5, vy: -1.5, d: 60 };
var b3 = { x: 100, y: 100, vx: 0.5, vy:  1.5, d: 30 };
var cont = { w: 400, h: 300, balls: [b1, b2, b3] };
   Мы видим, что нашу программу постепенно заселяют объекты, вытесняя из нее примитивные данные. Приостановим разработку и пополним наши знания об объектах.
  Объекты и конструкторы
   Как известно, объект это хранилище свойств. Создать объект можно, перечислив его свойства в фигурных скобках, или вызвав конструктор объекта. 
   Конструктором называют функцию, которая создает и возвращает объект. В теле конструктора ключевое слово this ссылается на объект, создаваемый конструктором. В JS в роли конструктора может выступить любая функция, если ее вызвать при помощи ключевого слова new. Именно благодаря вызову с new, this в теле конструктора становится ссылкой на объект. Напомним, что при обычном вызове функции ссылка this в ее теле равна undefined (в старых версиях JS this = window).
   
   Определим функцию Ball – конструктор шаров.
   
function Ball(x, y, d) {
    this.x = x;
    this.y = y;
    this.d = d;
    this.vx = Math.random();
    this.vy = Math.random();
}
   Конструктор Ball создает шар – объект с пятью свойствами. Трем из них, x, y и d, он присваивает значения, переданные через аргументы конструктора. Значения скоростей vx и vy выбираются случайным образом в интервале между 0 и 1. 
   Хотя со словом new можно вызвать любую функцию, конструктор специально готовят к своей роли – он должен придать начальные значения свойствам создаваемого объекта. Имя конструктора пишут с большой буквы. Несмотря на отсутствие явной команды return this, функция-конструктор всегда возвращает созданный ею объект. 
   Применим конструктор Ball для создания двух шаров.
   
var b1 = new Ball(0, 0, 50);
var b2 = new Ball(300, 200, 60);
   Для объекта контейнера тоже определим конструктор – функцию Cont. Пусть она получает ширину и высоту и создает пустой контейнер заданного размера.
   
function Cont(w, h) {
    this.w = w;
    this.h = h;
    this.balls = [];
}
   Применим конструктор для создания контейнера.
   
var cont = new Cont(400, 300);
   В целом программа Balls сейчас выглядит так.
   
// Конструкторы Cont и Ball (их код был показан выше)
function Cont(w, h) {…}
function Ball(x, y, d) {…}

function step(cont) {
    for (var i = 0; i < cont.balls.length; i++)
    {
        var b = cont.balls[i];

        if (b.x < 0 || b.x + b.d > cont.w)
            b.vx = -b.vx;
        if (b.y < 0 || b.y + b.d > cont.h)
            b.vy = -b.vy;

        b.x += b.vx;
        b.y += b.vy;
    }
}

function draw(cont) {
    var canvas = document.getElementById("canvas1");
    var ctx = canvas.getContext("2d");
    var img = document.getElementById("img1");

    ctx.clearRect(0, 0, cont.w, cont.h);
    ctx.strokeRect(0, 0, cont.w, cont.h);

    for (var i = 0; i < cont.balls.length; i++) {
        var b = cont.balls[i];
        ctx.drawImage(img, b.x, b.y, b.d, b.d);
    }
}

function main() {
    // Создание контейнера и наполнение шарами
    var cont = new Cont(400, 300);
    cont.balls.push(new Ball(0, 0, 50));
    cont.balls.push(new Ball(300, 200, 50));
    
    setInterval(function () {
        step(cont);
        draw(cont);
    }, 10);            
}

window.onload = main;
   Эту версию можно назвать Balls 1.2.
  Методы объектов
   Свойствами объекта могут быть не только данные, но и функции. Свойства-данные называют полями объекта, свойства-функции называют методами объекта. От обычных функций методы объекта отличаются тем, что работают со свойствами объекта и не работают со всем, что к объекту не относится. 
   Обратим внимание на отдельно стоящую функцию step. Для своей работы она нуждается только в объекте cont, и это дает основание сделать ее методом объекта-контейнера.
   
function Cont(w, h) 
{
    this.w = w;
    this.h = h;
    this.balls = [];
    
    var self = this;
    
    this.step = function () {
        for (var i = 0; i < self.balls.length; i++) {
            var b = self.balls[i];

            if (b.x < 0 || b.x + b.d > self.w)
                b.vx = -b.vx;
            if (b.y < 0 || b.y + b.d > self.h)
                b.vy = -b.vy;

            b.x += b.vx;
            b.y += b.vy;
        }
    }
}
   В теле метода step нам нужно обращаться к свойствам контейнера w, h и balls. Но мы не можем обратиться к ним так же, как обращались из тела конструктора, this.w, this.h и this.balls, потому, что только при вызове конструктора зарезервированное слово this будет ссылкой на конструируемый объект. Метод же объекта будет вызываться как обычная функция,
   	cont.step();
   поэтому слово this в теле метода не определено.
   В то же время в теле метода доступны локальные переменные функции-конструктора, поэтому мы создали в конструкторе локальную переменную self, в которой сохранили ссылку на конструируемый объект.
   	var self = this;
   Благодаря этой хитрости, к полям можно обращаться: self.w, welf.h, self.balls из любого метода. Хотя имя локальной переменной, сохраняющей ссылку this, роли не играет, принято называть такую переменную self.
   
   Назначение метода step – перебрать все шары и заставить каждый шар сделать один шаг. 
   Шаг одного шара можно запрограммировать в виде метода шара. Не слишком напрягая фантазию, дадим ему имя step.
    
function Ball(x, y, d) {
    this.x = x;
    this.y = y;
    this.d = d;
    this.vx = Math.random();
    this.vy = Math.random();

    var self = this;

    this.step = function (cont) {
        // изменение скорости при отражении от стенок 
        if (self.x < 0 || self.x + self.d > cont.w)
            self.vx = - self.vx;
        if (self.y < 0 || self.y + self.d > cont.h)
            self.vy = - self.vy;
        
        // изменение координат 
        self.x += self.vx;
        self.y += self.vy;
    }
}
   Метод шара step получает ссылку на контейнер в форме параметра. Вызываться step шара будет из метода step контейнера.

function Cont(w, h) {
    this.w = w;
    this.h = h;
    this.balls = [];
    
    var self = this;
    
    this.step = function () {
        for (var i = 0; i < self.balls.length; i++) {
            self.balls[i].step(self);
        }
    }
}
   Обособление всей логики передвижения шара в его методе step позволяет без изменения прочих частей программы добавлять новые факторы, влияющие на движение шара. Например, если мы хотим, чтобы на шары действовала «сила тяжести», достаточно в методе шара step перед изменением координат вставить следующую строку.
   
self.vy += 0.01;
   Если мы захотим, чтобы движение шаров постепенно замедлялось, как бы под воздействием трения или сопротивления воздуха, туда же нужно добавить еще две строки.
   
self.vx *= 0.998;
self.vy *= 0.998;
   Теперь код нашей модели состоит из определения двух конструкторов, Ball и Cont. Займемся другой частью программы – представлением. В настоящий момент оно имеет вид функции draw.
   
function draw(cont) {
    var canvas = document.getElementById("canvas1");
    var ctx = canvas.getContext("2d");
    var img = document.getElementById("img1");

    ctx.clearRect(0, 0, cont.w, cont.h);
    ctx.strokeRect(0, 0, cont.w, cont.h);

    for (var i = 0; i < cont.balls.length; i++) {
        var b = cont.balls[i];
        ctx.drawImage(img, b.x, b.y, b.d, b.d);
    }
}
   Сейчас функция draw решает две задачи: находит ссылки на элементы канваса, контекста и изображения и рисует модель. Но, во-первых это нарушает правило «одна функция – одна задача», во-вторых, определение ссылок делается всякий раз, когда нужно рисовать, а не однажды, как подсказывает здравый смысл.
   Чтобы исправить положение, учредим еще один объект, view, который будет отвечать в программе за представление модели на экране, а функцию draw сделаем его методом. Создавать объект, конечно же, будем при помощи конструктора.
   
function View(cont) {
    var canvas = document.getElementById("canvas1");
    var ctx = canvas.getContext("2d");
    var img = document.getElementById("img1");

    this.draw = function() {
        // очищаем прямоугольник контейнера
        ctx.clearRect(0, 0, cont.w, cont.h);

        // рисуем границы контейнера
        ctx.strokeRect(0, 0, cont.w, cont.h);
        
        // рисуем все шары
        for (var i = 0; i < cont.balls.length; i++) {
            var b = cont.balls[i];
            ctx.drawImage(img, b.x, b.y, b.d, b.d);
        }
    }
}
   В конструкторе View мы обошлись без локальной переменной self. Она не понадобилась потому, что методу draw не понадобились свойства объекта. Все необходимое метод draw получил из локальных переменных и параметра функции View – они входят в его лексическое окружение.
   Изменения, сделанные в программе, значительны, и настала пора выпустить версию Balls 2.0.
   
function Cont(w, h) { ... }

function Ball(x, y, d) { ... }

function View(cont) { ... }

function main() {
    // Создание модели 
    var cont = new Cont(400, 300);
    cont.balls.push(new Ball(0, 0, 50));
    cont.balls.push(new Ball(300, 200, 50));

    // Создание представления
    var view = new View(cont);

    // Запуск движения
    setInterval(function () {
        cont.step();
        view.draw();
    }, 10);            
}

window.onload = main;
   Эта версия включает три конструктора (их код был приведен ранее) и метода main, который создает модель, создает представление и запускает сердце программы – интервальный таймер.
   
18.1. В программе Ball контейнер всегда расположен в левом верхнем углу канваса. Измените программу так, чтобы контейнер мог располагаться в любом месте канваса, но не выходил за его пределы.
18.2. Добавьте в объект ball свойство color – цвет. Рисуя шары, обойдитесь без файла ball.png, а используйте метод fillCircle и цвет шара. 
18.3. Если шары надолго предоставить самим себе, под действием силы тяжести они "просачиваются" сквозь нижнюю границу контейнера. Что вы можете предложить для устранения этого недостатка модели?
  Заключение
1. Конструктор – это фабрика по создания объектов. За один вызов конструктора создается один объект. 
2. Формально любая функция может быть конструктором, если ее вызвать со словом new. Но фактически мы специально готовим функцию на эту роль: определяем поля и методы объекта this и именуем функцию с большой буквы. 
3. Собрание «под одной крышей» полей и методов характерно для объектов. В объектно-ориентированном программировании именно объекты, а не функции, образуют структуру программы.
19. Объектное проектирование
  Инкапсуляция
   Так получилось, что вся программа Ball 2.0, за исключением функции main, состоит из одних только конструкторов. Присмотримся к ним поближе.
   Конструктор создает поля, которые определяют состояние объекта, и методы, которые определяют поведение объекта, те и другие являются свойствами объекта. В коде конструктора свойства доступны через ссылку this – заместитель будущего объекта. Кроме свойств, в теле конструктора имеются локальные функции и локальные переменные, поэтому правомерен вопрос: чем свойства отличаются от локальных переменных и функций?
   Главное отличие в области видимости. Свойства принадлежат объекту и будут видны там, где виден их владелец – объект. Локальные имена (переменные, параметры конструктора, функции) видно только в теле конструктора. Проектируя конструктор, мы должны тщательно продумать состав свойств объекта и не включать в них ничего лишнего. 
   Задача локальных переменных и функций вспомогательная – обеспечить функционирование полей и методов объекта. 
   Состав локальных переменных и функций конструктора не требует столь тщательного проектирования, как свойства объекта. В процессе разработки их можно изменять, и  эти изменения никак не затронут другие части программы.
   Выбор минимально необходимого набора свойств и сокрытие всего остального внутри конструктора, называется инкапсуляцией и является важным принципом проектирования программ.
   Давайте посмотрим с этой точки зрения на конструктор Cont.
   
function Cont(w, h) {
    this.w = w;
    this.h = h;
    this.balls = [];
    var self = this;

    this.step = function () {
        for (var i = 0; i < self.balls.length; i++) {
            self.balls[i].step(self);
        }
    }
}
   Конструктор создает объект, который имеет три свойства: ширину, высоту и массив шаров. Все они предназначены только для чтения, но, поскольку это поля, их можно изменять. Легко можно придать объекту отрицательную ширину или записать что угодно в поле balls. Конечно, вы спросите, какой нехороший человек будет так поступать? Ответ простой – это будете вы сами. Ненамеренно, случайно, по забывчивости или по невнимательности, ведь не ошибается только тот, кто ничего не делает.
   Можно ли этому воспрепятствовать? Можно, но ценой некоторых усилий. Если вы твердо решили, что свою ширину и высоту контейнер должен предоставлять только для чтения, их нужно исключить из числа полей, и сделать методами.
   
function Cont(w, h) {
    this.getW = function() { return w; }
    this.getH = function() { return h; }

    this.balls = [];
    var self = this;

    this.step = function () {
        for (var i = 0; i < self.balls.length; i++) {
            self.balls[i].step(self);
        }
    }
}
   Поле balls оставим как есть, но добавим в контейнер пару полезных методов для добавления и удаления шаров.
   
    this.addBall = function (b) {
        self.balls.push(b);
    }

    this.removeBall = function (b) {
        var i = self.balls.indexOf(b);
        if (i != -1)
            self.balls = self.balls.splice(i, 1);
    }
19.1. Внесите в метод контейнера addBall проверку того, что добавляемый объект b имеет все свойства шара.
  Замыкание
   Возникает вопрос, почему методам объекта доступны локальные переменные, ведь конструктор уже завершил работу и освободил память? 
   Ответ такой: благодаря замыканию. 
   Замыкание – это сохранение в памяти лексического окружения функции до тех пор, пока существует сама функция. Метод – это функция, она существует, пока существует объект, и все это время в памяти сохраняются локальные переменные и локальные функции конструктора.
   Вот небольшой пример, который иллюстрирует сказанное.
   
function Test() {
    var v;
    this.get = function () { return v; }
    this.set = function (x) { v = x; }
}

var t1 = new Test();
var t2 = new Test();
t1.set(1);
t2.set(2);
alert(t1.get());  // 1
alert(t2.get());  // 2
   Пример показывает, что объекты t1 и t2 на всем протяжении своего существования пользуются локальной переменной конструктора v, причем каждый – своей собственной копией.
  Прототип объекта
   Обратим свое внимание на конструктор Ball.
   
function Ball(x, y, d) {
    this.x = x;
    this.y = y;
    this.d = d;
    this.vx = Math.random();
    this.vy = Math.random();

    var G = 0.01;
    var K = 0.998;

    var self = this;

    this.step = function (cont) {/* код опущен */ }
}
   Шаров в нашей программе может быть создано сколько угодно. Каждый создаваемый конструктором шар имеет индивидуальные черты ( поля x, y, d, vx, vy), и общие для всех шаров константы (G, K) и ссылки на методы (пока у шара только один метод, но вообще говоря, их может быть много). 
   Нерационально хранить в каждом шаре ссылки на методы и локальные константы (которые сохранятся благодаря замыканию) – они одинаковы для всех. Лучше собрать их в отдельном объекте, а в шаре оставить лишь одну ссылку на этот объект. И такой объект JS для нас уже приготовил, это прототип.
   Каждый объект JS имеет ссылку на свой прототип. Когда мы вызываем какое-то свойство объекта, интерпретатор ищет его сначала в самом объекте, а если не находит, то в его прототипе. Если все шары будут иметь общий прототип, то в нем и нужно сосредоточить все  функциональные свойства (т.е. методы). 
   Создавать методы чаще всего приходится в конструкторе, поэтому там и следует задавать общий прототип всем создаваемым объектам. Посмотрим, как это делается в JS.
    Все функции JS имеют свойство prototype, и когда функция вызывается как конструктор, это свойство ссылается на прототип конструируемого объекта. Первоначально этот прототип представляет собой объект с единственным свойством:
   
{ constructor: Ball}
   Но его можно дополнить необходимыми свойствами. Перенесем в Ball.prototype сначала константы, а затем и метод step. 
   
Ball.prototype.G = 0.01;
Ball.prototype.K = 0.998;

Ball.prototype.step = function (cont)
{
    if (this.x < 0 || this.x + this.d > cont.getW())
        this.vx = -this.vx;
    if (this.y < 0 || this.y + this.d > cont.getH())
        this.vy = -this.vy;

    if (this.y + this.d < cont.getH())
        this.vy += this.G;

    this.vx *= this.K;
    this.vy *= this.K;

    this.x += this.vx;
    this.y += this.vy;
}
   Бонусом к этому является то, что смысл слова this внутри методов прототипа такой же, как в теле конструктора – заместитель создаваемого объекта, и надобность в локальной переменной self отпадает.
   
   Конструктор Ball, очищенный от методов и констант, выглядит гораздо лучше.
   
function Ball(x, y, d) {
    this.x = x;
    this.y = y;
    this.d = d;
    this.vx = Math.random();
    this.vy = Math.random();
}
19.2. Перенесите в прототип объекта Cont методы step, addBall и removeBall.
   Расширение встроенных типов
   Благодаря прототипам, можно придать новые свойства любым объектам, в том числе и встроенным, например строкам.
   Только для демонстрации этого чуда снабдим строки не слишком нужным методом sumСodes, который возвращает сумму кодов символов, составляющих строку.
   
String.prototype.sumСodes = function () {
    var sum = 0;
    for (var i = 0; i < this.length; i++)
        sum += this.charCodeAt(i);
    return sum;
}
   После такого присваивания все строки обретут новый метод, sumCodes.
   
alert("aaa".sumCodes());   // 291
19.3. Расширьте числовой тип (Number) методом isPrime, который для всех простых чисел будет возвращать значение True, для составных False, а для нецелых undefined. 
  Заключение
1. Инкапсуляция – это предоставление пользователю объекта лишь того, что ему действительно необходимо, и сокрытие всех вспомогательных элементов за локальными именами.
2. Локальные имена (переменных, функций, параметров) доступны из методов объекта благодаря замыканию, которое сохраняет их в памяти на протяжении всего времени жизни объекта.
3. Каждый объект имеет прототип – другой объект. Свойства объекта могут храниться как в самом объекте, так и в его прототипе. Именно в такой последовательности их ищет интерпретатор.
20. Модель, представление, контроллер
   В этом разделе мы напишем еще одну программу с анимацией. Это будет действующая модель солнечной системы с центральным светилом и планетами вокруг. В отличие от своего прообраза – настоящей Солнечной системы, модель будет управляемой. Пользователь сможет добавлять и удалять планеты, изменять их орбиты, словом, чувствовать себя креативно.
  Механика
   Прежде, чем приступить к программированию, нужно сказать несколько слов о небесной механике. 
   Согласно закону Ньютона со стороны Солнца на любую планету действует сила 
   F = - G * M * m / r2,                       (20.1)
   где G – постоянная гравитации, M – масса Солнца, m – масса планеты, r – расстояние между центрами планеты и Солнца.
   Силой, которая действует на Солнце со стороны планеты, мы пренебрегаем и, вслед за Коперником, считаем Солнце неподвижным телом  в центре космоса. Также пренебрегаем и взаимным притяжением планет. 
   Сила придает планете ускорение, которое по второму закону Ньютона прямо пропорционально силе и обратно пропорционально массе планеты.
   a = F / m = - G * M / r2.
   Ускорение это вектор, направленный так же как сила, от планеты к солнцу. Поэтому его составляющие, по осям координат, можно определить из подобия треугольников.
   
   
   
   Рисунок 20.1 – Солнце и планета            
   
   		ax = x  * a / r;               (20.2)
              	ay = y  * a / r;
   
   Ускорение это приращение скорости в единицу времени. За очень малое время ускорение не успевает измениться, и его можно считать постоянным. Поэтому приращение скорости равно произведению ускорения a на время t. Поскольку время в программе измеряется в шагах, то за один шаг
   
   vx = vx + ax * 1; ;               (20.3)
   vy += vy + ay * 1;

   Остается понять, насколько точны наши расчеты, иными словами, t = 1 это большой или маленький отрезок времени? Ответ таков: если скорости планет и сила, действующая на них, не велики, то наша механическая модель будет достаточно точной.
  Модель
   Планета
   Модель состоит из двух типов объектов. Первый тип объекта – планета. Она напоминает шар из программы Balls.
   
function Planet(name, diam) {
    this.name = name;
    this.diam = diam;
}

Planet.prototype.GM = 1000;

Planet.prototype.step = function () {
    var r = Math.sqrt(this.x * this.x + this.y * this.y);
    var a = -this.GM / (r * r);

    var ax = this.x * a / r;
    var ay = this.y * a / r;

    this.vx += ax;
    this.vy += ay;

    this.x += this.vx;
    this.y += this.vy;
}
   Подобно шару планета имеет координаты (x и y) и скорость (vx и vy), но при создании планеты будем задавать только ее название и диаметр.  Координаты и начальную скорость будем задавать при включении планеты в солнечную систему, о которой речь впереди.
   Константа GM это произведение постоянной гравитации Ньютона на массу Солнца. Численное значение этого произведения зависит от единиц измерения. Единицей времени в нашей вселенной является один вызов метода step, единицей длины является пиксель. Мы не знаем, сколько миллионов километров в одном пикселе и сколько секунд в одном шаге, поэтому мы не можем взять известные науке значения G и M и просто перемножить. Нам придется подобрать приемлемое значение GM экспериментально. 
   Метод Planet.step делает то же, что метод Ball.step – изменяет скорость и координаты планеты за единицу времени. Законы механики мы уже обсудили, в методе step находятся формулы (20.1) - (20.3), переписанные на JS. Напоминаем, что формулы предполагают расположение Солнца в начале координат, так они выглядят наиболее просто.
   Солнечная система
   Второй тип объекта – солнечная система в целом. Роль этого объекта напоминает роль контейнера из программы Balls, только вместо массива шаров массив планет. 
   
function Solar() {
    this.planets = [];
}

Solar.prototype.step = function () {
    for (var i = 0; i < this.planets.length; i++) {
        this.planets[i].step();
    }
}

Solar.prototype.setPlanet = function (p, r) {
    p.x = r;
    p.y = 0;
    p.vx = 0;
    p.vy = Math.sqrt(p.GM / r);

    this.planets.push(p);
}
   Метод step в точности повторяет метод контейнера из Balls. 
   Метод setPlanet служит для включенияпланеты в Солнечную систему. Он получает p – планету и r – расстояние от планеты до Солнца. Планета будет установлена справа от светила на расстоянии r по оси Ox. Скорость подобрана так, чтобы планета вращалась вокруг Солнца по круговой орбите (рис.20.2).
   
   Рисунок 20.2 – Установка планета    
   
   Нам будет легче вести разработку, если разные части программы мы будем хранить в разных файлах. Все, относящееся к модели, а это конструкторы Solar и Planet, поместим в файл model.js.
  Представление
   Задача представления проста и понятна – отображать модель. Для отображения необходимо получить ссылку на канвас. 
   
var canvas = document.getElementById("canvas1");
   Получать ссылки на элементы страницы нам придется неоднократно, и неплохо было бы делать это покороче. Давать функциям псевдонимы в JS нельзя, но можно вызов одной функции обернуть в другую функцию.   
   
function el(id) {
    return document.getElementById(id);
}
   Функция el (от слова element) получает строку с id элемента и возвращает ссылку на элемент или undefined, если элемента с таким id в документе нет. 
   После этого маленького отступления возвращаемся к представлению – объекту, чей конструктор View показан ниже.

function View(solar) {
    var canvas = el("canvas1");
    var ctx = canvas.getContext("2d");
    var sunImg = el("sun");
    var sunDiam = 50;

    this.draw = function () {
        // черное небо космоса
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // начало координат - в центр канваса  
        ctx.save();
        ctx.translate(canvas.width / 2, canvas.height / 2);

        // рисуем Солнце
        ctx.drawImage(sunImg, 
            -sunDiam / 2, -sunDiam / 2, sunDiam, sunDiam);

        // рисуем планеты
        for (var i = 0; i < solar.planets.length; i++) {
            var p = solar.planets[i];
            var r = p.diam / 2;
            ctx.drawImage(el(p.name), 
                p.x - r, p.y - r, p.diam, p.diam);
        }
        ctx.restore();
    }
}
   Источником изображений Солнца и планет служат элементы img, спрятанные на html-странице. 
   О коде страницы речь пойдет позже, но можно заранее сказать, что среди прочих тэгов там находятся следующие.
   
    <img id="sun" src="sun.png" width="0" />
    <img id="planet1" src="planet1.png" width="0" />
    <img id="planet2" src="planet2.png" width="0" />
    <img id="planet3" src="planet3.png" width="0" />
   Изображения из элементов img связаны с объектами планет следующим соглашением: значение атрибута id элемента img должно совпадать со свойством планеты name.
   Изображения планет квадратные и выводятся так, чтобы координаты планеты (т.е. точка p.x, p.y) находилась в центре изображения.
   Представление, состоящее из конструктора View и независимой функции el, поместим в файл view.js.
  Сборка
   Функция main создает модель и представление, наполняет систему планетами и запускает ход времени. Она не относится ни к модели, ни к представлению, поэтому достойна отдельного файла, main.js. 
   
function main() {
    var model = new Solar();
    var view = new View(model);

    model.setPlanet(new Planet("planet1", 30), 150);
    model.setPlanet(new Planet("planet2", 40), 250);
    model.setPlanet(new Planet("planet3", 20), 350);

    setInterval(function () {
        model.step();
        view.draw();
    }, 10);
}

window.onload = main;
   
   Замечание. Распределение кода по нескольким файлам удобно для разработчика, но увеличивает время загрузки страницы в браузер. Снять противоречие позволяют программные инструменты для объединения файлов и сжатия кода, но здесь мы обойдемся без них. 
   
   Страница planets.html будет такой.
   
<!DOCTYPE html>
<html>
<head>
    <script src="model.js"></script>
    <script src="view.js"></script>
    <script src="main.js"></script>
</head>
<body>
    <canvas id="canvas1" width="800" height="800" ></canvas>

    <img id="sun" src="sun.png" width="0" />
    <img id="planet1" src="planet1.png" width="0" />
    <img id="planet2" src="planet2.png" width="0" />
    <img id="planet3" src="planet3.png" width="0" />
</body>
</html>
   Неинтерактивную версию программы назовем Planets 1.0.
  Контроллер
   В нашей программе планеты движутся по законам Кеплера, их круговые орбиты – результат сознательного выбора начальной скорости. Измените начальную скорость, и орбита планеты станет эллипсом, вот только вносить изменения затруднительно – нужно изменять код.
   Сейчас мы добавим в нашу программу, состоящую из модели и представления, третью часть, которая позволит нам ставить опыты над вселенной. Задача этой части – получать команды от пользователя и от его имени управлять моделью, чем и объясняется название третьей части – контроллер.
   Команды от человека поступают в виде событий мыши, клавиатуры, джойстика, сенсорной панели и других подобных устройств. Команды модели контроллер подает в форме вызовов методов модели. 
   Поскольку задача контроллера превращать события от мыши и клавиатуры в вызовы методов модели, придадим ему вид объекта с методами – обработчиками событий.
   Управление временем
   Будем действовать постепенно и начнем с того, что добавим в программу пару кнопок, которые смогут запускать и останавливать движение планет. Панель с кнопками разместим на странице planеts.html сразу под канвасом.
   
    <div>
        <button id="start">Start</button>
        <button id="stop">Stop</button>
    </div>
   Первоначальный вариант контроллера, сохраненный в файле controller.js, показан ниже. 
   
function Controller(model, view) 
{
    var timerId;

    this.start = function () {
        // чтобы избежать повторного запуска таймера 
        if (timerId)
            return;

        timerId = setInterval(function () {
            model.step();
            view.draw();
        }, 10);
    };

    this.stop = function () {
        clearInterval(timerId);
        timerId = undefined;
    };

    el("start").onclick = this.start;
    el("stop").onclick = this.stop;
}
   Метод start запускает течение времени, метод stop останавливает время. 
   Казалось бы, эти методы можно сделать локальными функциями и даже прямо привязать их к событиям, например, так.
   
function Controller(model, view) 
{
    var timerId;

    el("start").onclick = function () {
        // чтобы избежать повторного запуска таймера 
        if (timerId)
            return;

        timerId = setInterval(function () {
            model.step();
            view.draw();
        }, 10);
    };

    el("stop").onclick = function () {
        clearInterval(timerId);
        timerId = null;
    };
}
   Но тогда мы бы лишились возможности вызывать их по своему усмотрению, поэтому оставим вариант с методами.
   В связи с появлением нового игрока – контроллера, функция main упростилась.
   
function main() {
    // MVC
    var model = new Solar();
    var view = new View(model);
    var controller = new Controller(model, view);

    // Конфигурация планет
    model.setPlanet(new Planet("planet1", 30), 150);
    model.setPlanet(new Planet("planet2", 40), 250);
    model.setPlanet(new Planet("planet3", 20), 350);

    view.draw();
}
   Управление гравитацией
   Важнейшей космологической константой в нашей маленькой вселенной является коэффициент GM, от него зависит сила притяжения к Солнцу. Для изменения коэффициента GM, нам понадобится текстовое поле, которое можно разместить радом с кнопками «Start» и «Stop».
   
    <div>
        <button id="start">Start</button>
        <button id="stop">Stop</button>
        GM = <input id="gm" type="text" />
    </div>
   Потребуется также метод контроллера, который сохранит новое значение коэффициента, введенное пользователем в текстовое поле.
   
function Controller(model, view) 
{
    // ...здесь все, что было в конструкторе раньше

    this.saveState = function () {
        var gm = +el("gm").value;
        if (gm > 0)
           Planet.prototype.GM = gm;
        else
           alert("GM должно быть положительным числом."); 
    }

    el("gm").onchange = this.saveState;

    el("gm").value = Planet.prototype.GM;
}
   Метод saveState берет строку из текстового поля, преобразует ее в число (для этого перед строкой стоит знак «+»), и если число положительное, делает его новым значением коэффициента GM. 
   Что будет, если пользователь по рассеянности введет не число? Введенная строка преобразуется в NaN, и результат сравнения gm > 0 будет негативным.
   Проверка корректности пользовательского ввода входит в обязанности разработчика. Если пользователь совершил ошибку, недостаточно просто сказать ему об этом, нужно пояснить, как ее исправить.
   Метод saveState сделан обработчиком события change элемента input. Событие происходит после изменения свойств элемента в тот момент, когда фокус ввода покидает элемент. 
   
   Замечание. Фокус ввода – это способность элемента страницы воспринимать ввод от клавиатуры. Естественно, что в каждый момент времени на странице может быть не более одного такого элемента. Обычно элемент, владеющий фокусом, как-то выделяется визуально, в поле ввода, например, появляется каретка. В браузере фокус ввода можно передать элементу, кликнув по нему мышкой, или путем последовательных нажатий клавиши tab.
   
   Последняя строка конструктора записывает начальное значение коэффициента GM в текстовое поле, чтобы пользователю было что изменять.
   Управление пространством
   Сделаем так, чтобы при помощи колеса мыши можно было менять масштаб изображения, при этом точка в центре канваса, где находится Солнце, пусть остается неподвижной. Для этого нам понадобится:
1) добавить в объект View свойство scale – текущий коэффициент масштабирования;
2) добавить в контроллер метод changeScale для изменения этого свойства. Метод будет обрабатывать событие will, которое происходит, когда вращают колесо мыши. Событие происходит с тем элементом, над которым располагается курсор мыши, это конечно, будет канвас;
3) дополнить метод представления draw еще одной трансформацией канваса перед рисованием солнца и планет. 

Выполним сначала пункты 1) и 3), дополнив код представления. Для большей ясности приведем весь конструктор View, показав дополнения жирным шрифтом.
   
function View(solar) {
    var canvas = el("canvas1");
    var ctx = canvas.getContext("2d");
    var sunImg = el("sun");
    var sunDiam = 50;

    this.scale = 1.0; 

    this.draw = function () {
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.save();
        ctx.translate(canvas.width / 2, canvas.height / 2);
        ctx.scale(this.scale, this.scale);

        ctx.drawImage(sunImg,
             -sunDiam / 2, -sunDiam / 2, sunDiam, sunDiam);

        for (var i = 0; i < solar.planets.length; i++) {
            var p = solar.planets[i];
            var r = p.diam / 2;
            ctx.drawImage(el(p.name),
                p.x - r, p.y - r, p.diam, p.diam);
        }
        ctx.restore();
    }
}
   Пункт 2) заключается в еще одном методе контроллера.
   
function Controller(model, view) 
{
    // ...здесь все, что было в конструкторе раньше
        
    this.changeScale = function () {
        var k = 1.1;
        view.scale *= event.wheelDelta > 0 ? k : 1/k;
        view.draw();
    }

    el("canvas1").onwheel = this.changeScale;
}
   За один оборот колеса мыши масштаб изображения увеличивается или уменьшается на 10%.
   Интерактивную версию программы назовем Planets 2.0. На этом мы остановимся, и дальше улучшать программу вы должны самостоятельно. Начать можно со следующих задач.
   
20.1. Добавьте возможность выбрать одну из планет, кликнув по ней мышкой. Выбранная планета должна как-то выделяться визуально, например, рамкой вокруг.
20.2. Добавьте возможность изменить скорость выделенной планеты. Это можно сделать при помощи двух полей ввода, для vx и для vy, или любым иным способом, какой сможете придумать.
20.3. Показывайте текущую скорость планеты в форме стрелки, направленной из центра планеты.
20.4. Показывайте пройденный путь планеты точками.
  Шаблон MVC 
   Шаблон проектирования программы в виде трех слабо связанных между собой частей: модели, представления и контроллера известен в программировании давно.  
   Историческая справка
   Концепция MVC была описана в 1979 году Трюгве Реенскаугом, работавшим в то время над языком программирования Smalltalk. 
   С самого начала различали две основные модификации:
   Пассивная модель — модель не зависит от представления и контроллера, и используется ими в качестве источника данных для отображения. Все изменения модели отслеживаются контроллером, и он же отвечает за перерисовку представления, если это необходимо. 
   Активная модель — модель издает события, которые оповещают о том, что в ней произошли изменения, а представления (их может быть много), обрабатывают эти события.
   Сейчас количество различных вариаций концепции MVC измеряется десятками.

   Мы использовали раннюю версию шаблона – с пассивной моделью. В этой версии модель независима от других частей, поэтому разработку программы и внесение любых изменений следует начинать с нее.
    Представление использует данные модели для изображения ее на экране, и следовательно, зависит от модели.
   Контроллер изменяет состояние модели и сообщает представлению о необходимости перерисовки. Для этого контроллер должен иметь зависимость и от модели,  и от представления.
   На рисунке 20.3 зависимости между частями шаблона показаны стрелками, например, стрелка, ведущая от V к M, означает, что V зависит от M.
   
   Рисунок 20.3 – Шаблон MVC с пассивной моделью
   
   Рисунок 20.3 хорошо согласуется с той частью кода функции main, в которой создаются и связываются три части шаблона.
   
    // MVC
    var model = new Solar();
    var view = new View(model);
    var controller = new Controller(model, view);
  Заключение
1. Проектирование программы начинается с декомпозиции задачи. Сделать первый шаг в этом направлении вам поможет шаблон проектирования MVC.
2. Во всех модификациях шаблона MVC модель независима. Задача модели – представлять в программе предметную область. Это могут быть законы механики, правила бизнеса, правила игры в шахматы и т.п.
3. Задача представления – показать модель пользователю. Одна и та же модель может быть изображена по-разному, например,  функцию можно показать в виде формулы, в виде графика, в виде таблицы. Это означает, что представлений в программе может быть больше одного.
4. Там, где модель подвергается воздействию со стороны пользователя, необходим контроллер. Чем разнообразней эти воздействия, тем весомее роль контроллера.
Заключительное слово
   
   Этот курс дал вам очень много – вы освоили самый известный язык программирования и начали писать на нем программы, т.е. фактически стали программистами.
   Этот курс дал очень мало – поверхностное знание JS, смутное представление о процессе выполнения, несколько общеизвестных алгоритмов. 
   Какое из этих утверждений истинно? Это – зависит. Если вы намерены и впредь заниматься программированием, то первое, если думаете заняться чем-нибудь другим, то второе. Но хочется верить в первый вариант, поэтому стоит наметить, куда двигаться дальше.
   Следующим шагом в вашем программистском образовании может быть объектно-ориентированное программирование. Объектно-ориентированная парадигма наиболее распространена в современном программировании, но в JS ее поддержка весьма специфична, и лучше знакомиться с нею на примере статически типизированного языка, такого как Java или C#. 
   В статически типизированных языках типом обладают не только значения, но и имена. Это ограничивает свободу действий программиста, но дополнительно вооружает его для борьбы со сложностью. В больших проектах предпочитают языки со статической типизацией.
   Дальше вас ждут базы данных, функциональное программирование, операционные системы, язык C++, серверное и клиентское web-программирование и еще много разного. Порядок изучения определяет программа вуза, а если будете образовываться сами, то начинайте с того, для чего есть дополнительная мотивация – программы по работе или проекты для себя. Впрочем, базы данных, скорее всего, понадобятся первыми.
   Одно можно сказать определенно, если вы дочитали до этого места, значит, программирование вас радует, и вы будете получать удовольствие от изучения любой новой для вас технологии и любого языка. В общем, как сказал поэт: 
   Лучше гор могут быть только горы, 
   На которых еще не бывал.
  Литература
   
1. Макконнелл С. Совершенный код. Мастер-класс / Пер. с англ. — М. : Издательство «Русская редакция», 2010. — 896 стр.

2. Абельсон Х, Сассман Д. Структура и интерпретация компьютерных программ. – Добросвет, КДУ, 2010. – 608 c.

3. https://learn.javascript.ru/ - Современный учебник JavaScript
   
   
   

   
    
   
   191
    
   
